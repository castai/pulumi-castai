# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'WorkloadScalingPolicyAntiAffinityArgs',
    'WorkloadScalingPolicyAntiAffinityArgsDict',
    'WorkloadScalingPolicyAssignmentRuleArgs',
    'WorkloadScalingPolicyAssignmentRuleArgsDict',
    'WorkloadScalingPolicyAssignmentRuleRuleArgs',
    'WorkloadScalingPolicyAssignmentRuleRuleArgsDict',
    'WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs',
    'WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgsDict',
    'WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs',
    'WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgsDict',
    'WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs',
    'WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgsDict',
    'WorkloadScalingPolicyConfidenceArgs',
    'WorkloadScalingPolicyConfidenceArgsDict',
    'WorkloadScalingPolicyCpuArgs',
    'WorkloadScalingPolicyCpuArgsDict',
    'WorkloadScalingPolicyCpuApplyThresholdStrategyArgs',
    'WorkloadScalingPolicyCpuApplyThresholdStrategyArgsDict',
    'WorkloadScalingPolicyCpuLimitArgs',
    'WorkloadScalingPolicyCpuLimitArgsDict',
    'WorkloadScalingPolicyDownscalingArgs',
    'WorkloadScalingPolicyDownscalingArgsDict',
    'WorkloadScalingPolicyMemoryArgs',
    'WorkloadScalingPolicyMemoryArgsDict',
    'WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs',
    'WorkloadScalingPolicyMemoryApplyThresholdStrategyArgsDict',
    'WorkloadScalingPolicyMemoryEventArgs',
    'WorkloadScalingPolicyMemoryEventArgsDict',
    'WorkloadScalingPolicyMemoryLimitArgs',
    'WorkloadScalingPolicyMemoryLimitArgsDict',
    'WorkloadScalingPolicyPredictiveScalingArgs',
    'WorkloadScalingPolicyPredictiveScalingArgsDict',
    'WorkloadScalingPolicyPredictiveScalingCpuArgs',
    'WorkloadScalingPolicyPredictiveScalingCpuArgsDict',
    'WorkloadScalingPolicyRolloutBehaviorArgs',
    'WorkloadScalingPolicyRolloutBehaviorArgsDict',
    'WorkloadScalingPolicyStartupArgs',
    'WorkloadScalingPolicyStartupArgsDict',
]

MYPY = False

if not MYPY:
    class WorkloadScalingPolicyAntiAffinityArgsDict(TypedDict):
        consider_anti_affinity: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines if anti-affinity should be considered when scaling the workload.
        	If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
        """
elif False:
    WorkloadScalingPolicyAntiAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyAntiAffinityArgs:
    def __init__(__self__, *,
                 consider_anti_affinity: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] consider_anti_affinity: Defines if anti-affinity should be considered when scaling the workload.
               	If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
        """
        if consider_anti_affinity is not None:
            pulumi.set(__self__, "consider_anti_affinity", consider_anti_affinity)

    @_builtins.property
    @pulumi.getter(name="considerAntiAffinity")
    def consider_anti_affinity(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines if anti-affinity should be considered when scaling the workload.
        	If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
        """
        return pulumi.get(self, "consider_anti_affinity")

    @consider_anti_affinity.setter
    def consider_anti_affinity(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consider_anti_affinity", value)


if not MYPY:
    class WorkloadScalingPolicyAssignmentRuleArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleArgsDict']]]
elif False:
    WorkloadScalingPolicyAssignmentRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyAssignmentRuleArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleArgs']]]):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class WorkloadScalingPolicyAssignmentRuleRuleArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgsDict']]
        """
        Allows assigning a scaling policy based on the workload's namespace.
        """
        workload: NotRequired[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgsDict']]
        """
        Allows assigning a scaling policy based on the workload's metadata.
        """
elif False:
    WorkloadScalingPolicyAssignmentRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyAssignmentRuleRuleArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs']] = None,
                 workload: Optional[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs']] = None):
        """
        :param pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs'] namespace: Allows assigning a scaling policy based on the workload's namespace.
        :param pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs'] workload: Allows assigning a scaling policy based on the workload's metadata.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if workload is not None:
            pulumi.set(__self__, "workload", workload)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs']]:
        """
        Allows assigning a scaling policy based on the workload's namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs']]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def workload(self) -> Optional[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs']]:
        """
        Allows assigning a scaling policy based on the workload's metadata.
        """
        return pulumi.get(self, "workload")

    @workload.setter
    def workload(self, value: Optional[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs']]):
        pulumi.set(self, "workload", value)


if not MYPY:
    class WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgsDict(TypedDict):
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Defines matching by namespace names.
        """
elif False:
    WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs:
    def __init__(__self__, *,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] names: Defines matching by namespace names.
        """
        if names is not None:
            pulumi.set(__self__, "names", names)

    @_builtins.property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Defines matching by namespace names.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "names", value)


if not MYPY:
    class WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgsDict(TypedDict):
        gvks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Group, version, and kind for Kubernetes resources. Format: kind[.version][.group].
        It can be either:
         - only kind, e.g. "Deployment"
         - group and kind: e.g."Deployment.apps"
         - group, version and kind: e.g."Deployment.v1.apps"
        """
        labels_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgsDict']]]]
        """
        Defines matching by label selector requirements.
        """
elif False:
    WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs:
    def __init__(__self__, *,
                 gvks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 labels_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] gvks: Group, version, and kind for Kubernetes resources. Format: kind[.version][.group].
               It can be either:
                - only kind, e.g. "Deployment"
                - group and kind: e.g."Deployment.apps"
                - group, version and kind: e.g."Deployment.v1.apps"
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs']]] labels_expressions: Defines matching by label selector requirements.
        """
        if gvks is not None:
            pulumi.set(__self__, "gvks", gvks)
        if labels_expressions is not None:
            pulumi.set(__self__, "labels_expressions", labels_expressions)

    @_builtins.property
    @pulumi.getter
    def gvks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Group, version, and kind for Kubernetes resources. Format: kind[.version][.group].
        It can be either:
         - only kind, e.g. "Deployment"
         - group and kind: e.g."Deployment.apps"
         - group, version and kind: e.g."Deployment.v1.apps"
        """
        return pulumi.get(self, "gvks")

    @gvks.setter
    def gvks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "gvks", value)

    @_builtins.property
    @pulumi.getter(name="labelsExpressions")
    def labels_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs']]]]:
        """
        Defines matching by label selector requirements.
        """
        return pulumi.get(self, "labels_expressions")

    @labels_expressions.setter
    def labels_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs']]]]):
        pulumi.set(self, "labels_expressions", value)


if not MYPY:
    class WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        The operator to use for matching the label.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The label key to match. Required for all operators except `Regex` and `Contains`. If not specified, it will search through all labels.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of values to match against the label key. It is required for `In`, `NotIn`, `Regex`, and `Contains` operators.
        """
elif False:
    WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: The operator to use for matching the label.
        :param pulumi.Input[_builtins.str] key: The label key to match. Required for all operators except `Regex` and `Contains`. If not specified, it will search through all labels.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: A list of values to match against the label key. It is required for `In`, `NotIn`, `Regex`, and `Contains` operators.
        """
        pulumi.set(__self__, "operator", operator)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to use for matching the label.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The label key to match. Required for all operators except `Regex` and `Contains`. If not specified, it will search through all labels.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of values to match against the label key. It is required for `In`, `NotIn`, `Regex`, and `Contains` operators.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class WorkloadScalingPolicyConfidenceArgsDict(TypedDict):
        threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Defines the confidence threshold for applying recommendations. The smaller number indicates that we require fewer metrics data points to apply recommendations - changing this value can cause applying less precise recommendations. Do not change the default unless you want to optimize with fewer data points (e.g., short-lived workloads).
        """
elif False:
    WorkloadScalingPolicyConfidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyConfidenceArgs:
    def __init__(__self__, *,
                 threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] threshold: Defines the confidence threshold for applying recommendations. The smaller number indicates that we require fewer metrics data points to apply recommendations - changing this value can cause applying less precise recommendations. Do not change the default unless you want to optimize with fewer data points (e.g., short-lived workloads).
        """
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Defines the confidence threshold for applying recommendations. The smaller number indicates that we require fewer metrics data points to apply recommendations - changing this value can cause applying less precise recommendations. Do not change the default unless you want to optimize with fewer data points (e.g., short-lived workloads).
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class WorkloadScalingPolicyCpuArgsDict(TypedDict):
        apply_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        """
        apply_threshold_strategy: NotRequired[pulumi.Input['WorkloadScalingPolicyCpuApplyThresholdStrategyArgsDict']]
        """
        Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        """
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        """
        function: NotRequired[pulumi.Input[_builtins.str]]
        """
        The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        """
        limit: NotRequired[pulumi.Input['WorkloadScalingPolicyCpuLimitArgsDict']]
        """
        Resource limit settings
        """
        look_back_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The look back period in seconds for the recommendation.
        """
        management_option: NotRequired[pulumi.Input[_builtins.str]]
        """
        Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        """
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        overhead: NotRequired[pulumi.Input[_builtins.float]]
        """
        Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
elif False:
    WorkloadScalingPolicyCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyCpuArgs:
    def __init__(__self__, *,
                 apply_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 apply_threshold_strategy: Optional[pulumi.Input['WorkloadScalingPolicyCpuApplyThresholdStrategyArgs']] = None,
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 function: Optional[pulumi.Input[_builtins.str]] = None,
                 limit: Optional[pulumi.Input['WorkloadScalingPolicyCpuLimitArgs']] = None,
                 look_back_period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 management_option: Optional[pulumi.Input[_builtins.str]] = None,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None,
                 overhead: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] apply_threshold: The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        :param pulumi.Input['WorkloadScalingPolicyCpuApplyThresholdStrategyArgs'] apply_threshold_strategy: Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        :param pulumi.Input[_builtins.str] args: The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        :param pulumi.Input[_builtins.str] function: The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        :param pulumi.Input['WorkloadScalingPolicyCpuLimitArgs'] limit: Resource limit settings
        :param pulumi.Input[_builtins.int] look_back_period_seconds: The look back period in seconds for the recommendation.
        :param pulumi.Input[_builtins.str] management_option: Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        :param pulumi.Input[_builtins.float] max: Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param pulumi.Input[_builtins.float] min: Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param pulumi.Input[_builtins.float] overhead: Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        if apply_threshold is not None:
            warnings.warn("""Use apply_threshold_strategy instead""", DeprecationWarning)
            pulumi.log.warn("""apply_threshold is deprecated: Use apply_threshold_strategy instead""")
        if apply_threshold is not None:
            pulumi.set(__self__, "apply_threshold", apply_threshold)
        if apply_threshold_strategy is not None:
            pulumi.set(__self__, "apply_threshold_strategy", apply_threshold_strategy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if look_back_period_seconds is not None:
            pulumi.set(__self__, "look_back_period_seconds", look_back_period_seconds)
        if management_option is not None:
            pulumi.set(__self__, "management_option", management_option)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)

    @_builtins.property
    @pulumi.getter(name="applyThreshold")
    @_utilities.deprecated("""Use apply_threshold_strategy instead""")
    def apply_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        """
        return pulumi.get(self, "apply_threshold")

    @apply_threshold.setter
    def apply_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "apply_threshold", value)

    @_builtins.property
    @pulumi.getter(name="applyThresholdStrategy")
    def apply_threshold_strategy(self) -> Optional[pulumi.Input['WorkloadScalingPolicyCpuApplyThresholdStrategyArgs']]:
        """
        Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        """
        return pulumi.get(self, "apply_threshold_strategy")

    @apply_threshold_strategy.setter
    def apply_threshold_strategy(self, value: Optional[pulumi.Input['WorkloadScalingPolicyCpuApplyThresholdStrategyArgs']]):
        pulumi.set(self, "apply_threshold_strategy", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['WorkloadScalingPolicyCpuLimitArgs']]:
        """
        Resource limit settings
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['WorkloadScalingPolicyCpuLimitArgs']]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="lookBackPeriodSeconds")
    def look_back_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The look back period in seconds for the recommendation.
        """
        return pulumi.get(self, "look_back_period_seconds")

    @look_back_period_seconds.setter
    def look_back_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "look_back_period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="managementOption")
    def management_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        """
        return pulumi.get(self, "management_option")

    @management_option.setter
    def management_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_option", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def overhead(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        return pulumi.get(self, "overhead")

    @overhead.setter
    def overhead(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "overhead", value)


if not MYPY:
    class WorkloadScalingPolicyCpuApplyThresholdStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Defines apply theshold strategy type.
        	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
            - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
            - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        """
        denominator: NotRequired[pulumi.Input[_builtins.str]]
        """
        If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        exponent: NotRequired[pulumi.Input[_builtins.float]]
        """
        The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
        	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
        	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
        	It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        numerator: NotRequired[pulumi.Input[_builtins.float]]
        """
        The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        percentage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
elif False:
    WorkloadScalingPolicyCpuApplyThresholdStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyCpuApplyThresholdStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 denominator: Optional[pulumi.Input[_builtins.str]] = None,
                 exponent: Optional[pulumi.Input[_builtins.float]] = None,
                 numerator: Optional[pulumi.Input[_builtins.float]] = None,
                 percentage: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Defines apply theshold strategy type.
               	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
                   - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
                   - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.str] denominator: If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.float] exponent: The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
               	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
               	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
               	It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.float] numerator: The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.float] percentage: Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        pulumi.set(__self__, "type", type)
        if denominator is not None:
            pulumi.set(__self__, "denominator", denominator)
        if exponent is not None:
            pulumi.set(__self__, "exponent", exponent)
        if numerator is not None:
            pulumi.set(__self__, "numerator", numerator)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Defines apply theshold strategy type.
        	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
            - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
            - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def denominator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "denominator")

    @denominator.setter
    def denominator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "denominator", value)

    @_builtins.property
    @pulumi.getter
    def exponent(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
        	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
        	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
        	It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "exponent")

    @exponent.setter
    def exponent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "exponent", value)

    @_builtins.property
    @pulumi.getter
    def numerator(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "numerator")

    @numerator.setter
    def numerator(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "numerator", value)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class WorkloadScalingPolicyCpuLimitArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Defines limit strategy type.
        	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
        	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
        	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        """
        multiplier: NotRequired[pulumi.Input[_builtins.float]]
        """
        Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
elif False:
    WorkloadScalingPolicyCpuLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyCpuLimitArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 multiplier: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Defines limit strategy type.
               	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
               	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
               	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        :param pulumi.Input[_builtins.float] multiplier: Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        pulumi.set(__self__, "type", type)
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Defines limit strategy type.
        	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
        	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
        	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def multiplier(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        return pulumi.get(self, "multiplier")

    @multiplier.setter
    def multiplier(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "multiplier", value)


if not MYPY:
    class WorkloadScalingPolicyDownscalingArgsDict(TypedDict):
        apply_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the apply type to be used when downscaling.
        	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
        	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
elif False:
    WorkloadScalingPolicyDownscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyDownscalingArgs:
    def __init__(__self__, *,
                 apply_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apply_type: Defines the apply type to be used when downscaling.
               	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
               	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        if apply_type is not None:
            pulumi.set(__self__, "apply_type", apply_type)

    @_builtins.property
    @pulumi.getter(name="applyType")
    def apply_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the apply type to be used when downscaling.
        	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
        	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        return pulumi.get(self, "apply_type")

    @apply_type.setter
    def apply_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apply_type", value)


if not MYPY:
    class WorkloadScalingPolicyMemoryArgsDict(TypedDict):
        apply_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        """
        apply_threshold_strategy: NotRequired[pulumi.Input['WorkloadScalingPolicyMemoryApplyThresholdStrategyArgsDict']]
        """
        Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        """
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        """
        function: NotRequired[pulumi.Input[_builtins.str]]
        """
        The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        """
        limit: NotRequired[pulumi.Input['WorkloadScalingPolicyMemoryLimitArgsDict']]
        """
        Resource limit settings
        """
        look_back_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The look back period in seconds for the recommendation.
        """
        management_option: NotRequired[pulumi.Input[_builtins.str]]
        """
        Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        """
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        overhead: NotRequired[pulumi.Input[_builtins.float]]
        """
        Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
elif False:
    WorkloadScalingPolicyMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyMemoryArgs:
    def __init__(__self__, *,
                 apply_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 apply_threshold_strategy: Optional[pulumi.Input['WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs']] = None,
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 function: Optional[pulumi.Input[_builtins.str]] = None,
                 limit: Optional[pulumi.Input['WorkloadScalingPolicyMemoryLimitArgs']] = None,
                 look_back_period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 management_option: Optional[pulumi.Input[_builtins.str]] = None,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None,
                 overhead: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] apply_threshold: The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        :param pulumi.Input['WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs'] apply_threshold_strategy: Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        :param pulumi.Input[_builtins.str] args: The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        :param pulumi.Input[_builtins.str] function: The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        :param pulumi.Input['WorkloadScalingPolicyMemoryLimitArgs'] limit: Resource limit settings
        :param pulumi.Input[_builtins.int] look_back_period_seconds: The look back period in seconds for the recommendation.
        :param pulumi.Input[_builtins.str] management_option: Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        :param pulumi.Input[_builtins.float] max: Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param pulumi.Input[_builtins.float] min: Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param pulumi.Input[_builtins.float] overhead: Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        if apply_threshold is not None:
            warnings.warn("""Use apply_threshold_strategy instead""", DeprecationWarning)
            pulumi.log.warn("""apply_threshold is deprecated: Use apply_threshold_strategy instead""")
        if apply_threshold is not None:
            pulumi.set(__self__, "apply_threshold", apply_threshold)
        if apply_threshold_strategy is not None:
            pulumi.set(__self__, "apply_threshold_strategy", apply_threshold_strategy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if look_back_period_seconds is not None:
            pulumi.set(__self__, "look_back_period_seconds", look_back_period_seconds)
        if management_option is not None:
            pulumi.set(__self__, "management_option", management_option)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)

    @_builtins.property
    @pulumi.getter(name="applyThreshold")
    @_utilities.deprecated("""Use apply_threshold_strategy instead""")
    def apply_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        """
        return pulumi.get(self, "apply_threshold")

    @apply_threshold.setter
    def apply_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "apply_threshold", value)

    @_builtins.property
    @pulumi.getter(name="applyThresholdStrategy")
    def apply_threshold_strategy(self) -> Optional[pulumi.Input['WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs']]:
        """
        Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        """
        return pulumi.get(self, "apply_threshold_strategy")

    @apply_threshold_strategy.setter
    def apply_threshold_strategy(self, value: Optional[pulumi.Input['WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs']]):
        pulumi.set(self, "apply_threshold_strategy", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['WorkloadScalingPolicyMemoryLimitArgs']]:
        """
        Resource limit settings
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['WorkloadScalingPolicyMemoryLimitArgs']]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="lookBackPeriodSeconds")
    def look_back_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The look back period in seconds for the recommendation.
        """
        return pulumi.get(self, "look_back_period_seconds")

    @look_back_period_seconds.setter
    def look_back_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "look_back_period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="managementOption")
    def management_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        """
        return pulumi.get(self, "management_option")

    @management_option.setter
    def management_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_option", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def overhead(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        return pulumi.get(self, "overhead")

    @overhead.setter
    def overhead(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "overhead", value)


if not MYPY:
    class WorkloadScalingPolicyMemoryApplyThresholdStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Defines apply theshold strategy type.
        	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
            - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
            - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        """
        denominator: NotRequired[pulumi.Input[_builtins.str]]
        """
        If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        exponent: NotRequired[pulumi.Input[_builtins.float]]
        """
        The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
        	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
        	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
        	It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        numerator: NotRequired[pulumi.Input[_builtins.float]]
        """
        The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        percentage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
elif False:
    WorkloadScalingPolicyMemoryApplyThresholdStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 denominator: Optional[pulumi.Input[_builtins.str]] = None,
                 exponent: Optional[pulumi.Input[_builtins.float]] = None,
                 numerator: Optional[pulumi.Input[_builtins.float]] = None,
                 percentage: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Defines apply theshold strategy type.
               	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
                   - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
                   - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.str] denominator: If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.float] exponent: The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
               	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
               	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
               	It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.float] numerator: The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param pulumi.Input[_builtins.float] percentage: Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        pulumi.set(__self__, "type", type)
        if denominator is not None:
            pulumi.set(__self__, "denominator", denominator)
        if exponent is not None:
            pulumi.set(__self__, "exponent", exponent)
        if numerator is not None:
            pulumi.set(__self__, "numerator", numerator)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Defines apply theshold strategy type.
        	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
            - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
            - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def denominator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "denominator")

    @denominator.setter
    def denominator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "denominator", value)

    @_builtins.property
    @pulumi.getter
    def exponent(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
        	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
        	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
        	It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "exponent")

    @exponent.setter
    def exponent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "exponent", value)

    @_builtins.property
    @pulumi.getter
    def numerator(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "numerator")

    @numerator.setter
    def numerator(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "numerator", value)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class WorkloadScalingPolicyMemoryEventArgsDict(TypedDict):
        apply_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the apply type to be used when applying recommendation for memory related event.
        	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
        	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
elif False:
    WorkloadScalingPolicyMemoryEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyMemoryEventArgs:
    def __init__(__self__, *,
                 apply_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apply_type: Defines the apply type to be used when applying recommendation for memory related event.
               	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
               	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        if apply_type is not None:
            pulumi.set(__self__, "apply_type", apply_type)

    @_builtins.property
    @pulumi.getter(name="applyType")
    def apply_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the apply type to be used when applying recommendation for memory related event.
        	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
        	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        return pulumi.get(self, "apply_type")

    @apply_type.setter
    def apply_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apply_type", value)


if not MYPY:
    class WorkloadScalingPolicyMemoryLimitArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Defines limit strategy type.
        	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
        	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
        	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        """
        multiplier: NotRequired[pulumi.Input[_builtins.float]]
        """
        Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
elif False:
    WorkloadScalingPolicyMemoryLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyMemoryLimitArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 multiplier: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Defines limit strategy type.
               	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
               	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
               	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        :param pulumi.Input[_builtins.float] multiplier: Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        pulumi.set(__self__, "type", type)
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Defines limit strategy type.
        	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
        	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
        	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def multiplier(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        return pulumi.get(self, "multiplier")

    @multiplier.setter
    def multiplier(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "multiplier", value)


if not MYPY:
    class WorkloadScalingPolicyPredictiveScalingArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['WorkloadScalingPolicyPredictiveScalingCpuArgsDict']]
        """
        Defines predictive scaling resource configuration.
        """
elif False:
    WorkloadScalingPolicyPredictiveScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyPredictiveScalingArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['WorkloadScalingPolicyPredictiveScalingCpuArgs']] = None):
        """
        :param pulumi.Input['WorkloadScalingPolicyPredictiveScalingCpuArgs'] cpu: Defines predictive scaling resource configuration.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['WorkloadScalingPolicyPredictiveScalingCpuArgs']]:
        """
        Defines predictive scaling resource configuration.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['WorkloadScalingPolicyPredictiveScalingCpuArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class WorkloadScalingPolicyPredictiveScalingCpuArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Defines if predictive scaling is enabled for resource.
        """
elif False:
    WorkloadScalingPolicyPredictiveScalingCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyPredictiveScalingCpuArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Defines if predictive scaling is enabled for resource.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Defines if predictive scaling is enabled for resource.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WorkloadScalingPolicyRolloutBehaviorArgsDict(TypedDict):
        prefer_one_by_one: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines if pods should be restarted one by one to avoid service disruption.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the rollout type to be used when applying recommendations.
        	- NO_DISRUPTION - pods are restarted without causing service disruption.
        """
elif False:
    WorkloadScalingPolicyRolloutBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyRolloutBehaviorArgs:
    def __init__(__self__, *,
                 prefer_one_by_one: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] prefer_one_by_one: Defines if pods should be restarted one by one to avoid service disruption.
        :param pulumi.Input[_builtins.str] type: Defines the rollout type to be used when applying recommendations.
               	- NO_DISRUPTION - pods are restarted without causing service disruption.
        """
        if prefer_one_by_one is not None:
            pulumi.set(__self__, "prefer_one_by_one", prefer_one_by_one)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="preferOneByOne")
    def prefer_one_by_one(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines if pods should be restarted one by one to avoid service disruption.
        """
        return pulumi.get(self, "prefer_one_by_one")

    @prefer_one_by_one.setter
    def prefer_one_by_one(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prefer_one_by_one", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the rollout type to be used when applying recommendations.
        	- NO_DISRUPTION - pods are restarted without causing service disruption.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WorkloadScalingPolicyStartupArgsDict(TypedDict):
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Defines the duration (in seconds) during which elevated resource usage is expected at startup.
        When set, recommendations will be adjusted to disregard resource spikes within this period.
        If not specified, the workload will receive standard recommendations without startup considerations.
        """
elif False:
    WorkloadScalingPolicyStartupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadScalingPolicyStartupArgs:
    def __init__(__self__, *,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] period_seconds: Defines the duration (in seconds) during which elevated resource usage is expected at startup.
               When set, recommendations will be adjusted to disregard resource spikes within this period.
               If not specified, the workload will receive standard recommendations without startup considerations.
        """
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Defines the duration (in seconds) during which elevated resource usage is expected at startup.
        When set, recommendations will be adjusted to disregard resource spikes within this period.
        If not specified, the workload will receive standard recommendations without startup considerations.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)


