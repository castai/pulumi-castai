# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'WorkloadScalingPolicyAntiAffinity',
    'WorkloadScalingPolicyAssignmentRule',
    'WorkloadScalingPolicyAssignmentRuleRule',
    'WorkloadScalingPolicyAssignmentRuleRuleNamespace',
    'WorkloadScalingPolicyAssignmentRuleRuleWorkload',
    'WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpression',
    'WorkloadScalingPolicyConfidence',
    'WorkloadScalingPolicyCpu',
    'WorkloadScalingPolicyCpuApplyThresholdStrategy',
    'WorkloadScalingPolicyCpuLimit',
    'WorkloadScalingPolicyDownscaling',
    'WorkloadScalingPolicyMemory',
    'WorkloadScalingPolicyMemoryApplyThresholdStrategy',
    'WorkloadScalingPolicyMemoryEvent',
    'WorkloadScalingPolicyMemoryLimit',
    'WorkloadScalingPolicyPredictiveScaling',
    'WorkloadScalingPolicyPredictiveScalingCpu',
    'WorkloadScalingPolicyRolloutBehavior',
    'WorkloadScalingPolicyStartup',
]

@pulumi.output_type
class WorkloadScalingPolicyAntiAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerAntiAffinity":
            suggest = "consider_anti_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyAntiAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyAntiAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyAntiAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consider_anti_affinity: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool consider_anti_affinity: Defines if anti-affinity should be considered when scaling the workload.
               	If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
        """
        if consider_anti_affinity is not None:
            pulumi.set(__self__, "consider_anti_affinity", consider_anti_affinity)

    @_builtins.property
    @pulumi.getter(name="considerAntiAffinity")
    def consider_anti_affinity(self) -> Optional[_builtins.bool]:
        """
        Defines if anti-affinity should be considered when scaling the workload.
        	If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
        """
        return pulumi.get(self, "consider_anti_affinity")


@pulumi.output_type
class WorkloadScalingPolicyAssignmentRule(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WorkloadScalingPolicyAssignmentRuleRule']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WorkloadScalingPolicyAssignmentRuleRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WorkloadScalingPolicyAssignmentRuleRule(dict):
    def __init__(__self__, *,
                 namespace: Optional['outputs.WorkloadScalingPolicyAssignmentRuleRuleNamespace'] = None,
                 workload: Optional['outputs.WorkloadScalingPolicyAssignmentRuleRuleWorkload'] = None):
        """
        :param 'WorkloadScalingPolicyAssignmentRuleRuleNamespaceArgs' namespace: Allows assigning a scaling policy based on the workload's namespace.
        :param 'WorkloadScalingPolicyAssignmentRuleRuleWorkloadArgs' workload: Allows assigning a scaling policy based on the workload's metadata.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if workload is not None:
            pulumi.set(__self__, "workload", workload)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional['outputs.WorkloadScalingPolicyAssignmentRuleRuleNamespace']:
        """
        Allows assigning a scaling policy based on the workload's namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def workload(self) -> Optional['outputs.WorkloadScalingPolicyAssignmentRuleRuleWorkload']:
        """
        Allows assigning a scaling policy based on the workload's metadata.
        """
        return pulumi.get(self, "workload")


@pulumi.output_type
class WorkloadScalingPolicyAssignmentRuleRuleNamespace(dict):
    def __init__(__self__, *,
                 names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] names: Defines matching by namespace names.
        """
        if names is not None:
            pulumi.set(__self__, "names", names)

    @_builtins.property
    @pulumi.getter
    def names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines matching by namespace names.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class WorkloadScalingPolicyAssignmentRuleRuleWorkload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelsExpressions":
            suggest = "labels_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyAssignmentRuleRuleWorkload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyAssignmentRuleRuleWorkload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyAssignmentRuleRuleWorkload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gvks: Optional[Sequence[_builtins.str]] = None,
                 labels_expressions: Optional[Sequence['outputs.WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpression']] = None):
        """
        :param Sequence[_builtins.str] gvks: Group, version, and kind for Kubernetes resources. Format: kind[.version][.group].
               It can be either:
                - only kind, e.g. "Deployment"
                - group and kind: e.g."Deployment.apps"
                - group, version and kind: e.g."Deployment.v1.apps"
        :param Sequence['WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpressionArgs'] labels_expressions: Defines matching by label selector requirements.
        """
        if gvks is not None:
            pulumi.set(__self__, "gvks", gvks)
        if labels_expressions is not None:
            pulumi.set(__self__, "labels_expressions", labels_expressions)

    @_builtins.property
    @pulumi.getter
    def gvks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Group, version, and kind for Kubernetes resources. Format: kind[.version][.group].
        It can be either:
         - only kind, e.g. "Deployment"
         - group and kind: e.g."Deployment.apps"
         - group, version and kind: e.g."Deployment.v1.apps"
        """
        return pulumi.get(self, "gvks")

    @_builtins.property
    @pulumi.getter(name="labelsExpressions")
    def labels_expressions(self) -> Optional[Sequence['outputs.WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpression']]:
        """
        Defines matching by label selector requirements.
        """
        return pulumi.get(self, "labels_expressions")


@pulumi.output_type
class WorkloadScalingPolicyAssignmentRuleRuleWorkloadLabelsExpression(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str operator: The operator to use for matching the label.
        :param _builtins.str key: The label key to match. Required for all operators except `Regex` and `Contains`. If not specified, it will search through all labels.
        :param Sequence[_builtins.str] values: A list of values to match against the label key. It is required for `In`, `NotIn`, `Regex`, and `Contains` operators.
        """
        pulumi.set(__self__, "operator", operator)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use for matching the label.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The label key to match. Required for all operators except `Regex` and `Contains`. If not specified, it will search through all labels.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of values to match against the label key. It is required for `In`, `NotIn`, `Regex`, and `Contains` operators.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class WorkloadScalingPolicyConfidence(dict):
    def __init__(__self__, *,
                 threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.float threshold: Defines the confidence threshold for applying recommendations. The smaller number indicates that we require fewer metrics data points to apply recommendations - changing this value can cause applying less precise recommendations. Do not change the default unless you want to optimize with fewer data points (e.g., short-lived workloads).
        """
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.float]:
        """
        Defines the confidence threshold for applying recommendations. The smaller number indicates that we require fewer metrics data points to apply recommendations - changing this value can cause applying less precise recommendations. Do not change the default unless you want to optimize with fewer data points (e.g., short-lived workloads).
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WorkloadScalingPolicyCpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyThreshold":
            suggest = "apply_threshold"
        elif key == "applyThresholdStrategy":
            suggest = "apply_threshold_strategy"
        elif key == "lookBackPeriodSeconds":
            suggest = "look_back_period_seconds"
        elif key == "managementOption":
            suggest = "management_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyCpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyCpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyCpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_threshold: Optional[_builtins.float] = None,
                 apply_threshold_strategy: Optional['outputs.WorkloadScalingPolicyCpuApplyThresholdStrategy'] = None,
                 args: Optional[_builtins.str] = None,
                 function: Optional[_builtins.str] = None,
                 limit: Optional['outputs.WorkloadScalingPolicyCpuLimit'] = None,
                 look_back_period_seconds: Optional[_builtins.int] = None,
                 management_option: Optional[_builtins.str] = None,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None,
                 overhead: Optional[_builtins.float] = None):
        """
        :param _builtins.float apply_threshold: The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        :param 'WorkloadScalingPolicyCpuApplyThresholdStrategyArgs' apply_threshold_strategy: Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        :param _builtins.str args: The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        :param _builtins.str function: The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        :param 'WorkloadScalingPolicyCpuLimitArgs' limit: Resource limit settings
        :param _builtins.int look_back_period_seconds: The look back period in seconds for the recommendation.
        :param _builtins.str management_option: Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        :param _builtins.float max: Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param _builtins.float min: Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param _builtins.float overhead: Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        if apply_threshold is not None:
            pulumi.set(__self__, "apply_threshold", apply_threshold)
        if apply_threshold_strategy is not None:
            pulumi.set(__self__, "apply_threshold_strategy", apply_threshold_strategy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if look_back_period_seconds is not None:
            pulumi.set(__self__, "look_back_period_seconds", look_back_period_seconds)
        if management_option is not None:
            pulumi.set(__self__, "management_option", management_option)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)

    @_builtins.property
    @pulumi.getter(name="applyThreshold")
    @_utilities.deprecated("""Use apply_threshold_strategy instead""")
    def apply_threshold(self) -> Optional[_builtins.float]:
        """
        The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        """
        return pulumi.get(self, "apply_threshold")

    @_builtins.property
    @pulumi.getter(name="applyThresholdStrategy")
    def apply_threshold_strategy(self) -> Optional['outputs.WorkloadScalingPolicyCpuApplyThresholdStrategy']:
        """
        Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        """
        return pulumi.get(self, "apply_threshold_strategy")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[_builtins.str]:
        """
        The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.str]:
        """
        The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional['outputs.WorkloadScalingPolicyCpuLimit']:
        """
        Resource limit settings
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="lookBackPeriodSeconds")
    def look_back_period_seconds(self) -> Optional[_builtins.int]:
        """
        The look back period in seconds for the recommendation.
        """
        return pulumi.get(self, "look_back_period_seconds")

    @_builtins.property
    @pulumi.getter(name="managementOption")
    def management_option(self) -> Optional[_builtins.str]:
        """
        Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        """
        return pulumi.get(self, "management_option")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def overhead(self) -> Optional[_builtins.float]:
        """
        Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        return pulumi.get(self, "overhead")


@pulumi.output_type
class WorkloadScalingPolicyCpuApplyThresholdStrategy(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 denominator: Optional[_builtins.str] = None,
                 exponent: Optional[_builtins.float] = None,
                 numerator: Optional[_builtins.float] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.str type: Defines apply theshold strategy type.
               	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
                   - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
                   - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        :param _builtins.str denominator: If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param _builtins.float exponent: The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
               	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
               	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
               	It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param _builtins.float numerator: The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param _builtins.float percentage: Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        pulumi.set(__self__, "type", type)
        if denominator is not None:
            pulumi.set(__self__, "denominator", denominator)
        if exponent is not None:
            pulumi.set(__self__, "exponent", exponent)
        if numerator is not None:
            pulumi.set(__self__, "numerator", numerator)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Defines apply theshold strategy type.
        	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
            - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
            - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def denominator(self) -> Optional[_builtins.str]:
        """
        If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "denominator")

    @_builtins.property
    @pulumi.getter
    def exponent(self) -> Optional[_builtins.float]:
        """
        The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
        	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
        	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
        	It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "exponent")

    @_builtins.property
    @pulumi.getter
    def numerator(self) -> Optional[_builtins.float]:
        """
        The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "numerator")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class WorkloadScalingPolicyCpuLimit(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 multiplier: Optional[_builtins.float] = None):
        """
        :param _builtins.str type: Defines limit strategy type.
               	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
               	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
               	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        :param _builtins.float multiplier: Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        pulumi.set(__self__, "type", type)
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Defines limit strategy type.
        	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
        	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
        	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def multiplier(self) -> Optional[_builtins.float]:
        """
        Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class WorkloadScalingPolicyDownscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyType":
            suggest = "apply_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyDownscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyDownscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyDownscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_type: Defines the apply type to be used when downscaling.
               	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
               	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        if apply_type is not None:
            pulumi.set(__self__, "apply_type", apply_type)

    @_builtins.property
    @pulumi.getter(name="applyType")
    def apply_type(self) -> Optional[_builtins.str]:
        """
        Defines the apply type to be used when downscaling.
        	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
        	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        return pulumi.get(self, "apply_type")


@pulumi.output_type
class WorkloadScalingPolicyMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyThreshold":
            suggest = "apply_threshold"
        elif key == "applyThresholdStrategy":
            suggest = "apply_threshold_strategy"
        elif key == "lookBackPeriodSeconds":
            suggest = "look_back_period_seconds"
        elif key == "managementOption":
            suggest = "management_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_threshold: Optional[_builtins.float] = None,
                 apply_threshold_strategy: Optional['outputs.WorkloadScalingPolicyMemoryApplyThresholdStrategy'] = None,
                 args: Optional[_builtins.str] = None,
                 function: Optional[_builtins.str] = None,
                 limit: Optional['outputs.WorkloadScalingPolicyMemoryLimit'] = None,
                 look_back_period_seconds: Optional[_builtins.int] = None,
                 management_option: Optional[_builtins.str] = None,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None,
                 overhead: Optional[_builtins.float] = None):
        """
        :param _builtins.float apply_threshold: The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        :param 'WorkloadScalingPolicyMemoryApplyThresholdStrategyArgs' apply_threshold_strategy: Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        :param _builtins.str args: The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        :param _builtins.str function: The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        :param 'WorkloadScalingPolicyMemoryLimitArgs' limit: Resource limit settings
        :param _builtins.int look_back_period_seconds: The look back period in seconds for the recommendation.
        :param _builtins.str management_option: Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        :param _builtins.float max: Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param _builtins.float min: Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        :param _builtins.float overhead: Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        if apply_threshold is not None:
            pulumi.set(__self__, "apply_threshold", apply_threshold)
        if apply_threshold_strategy is not None:
            pulumi.set(__self__, "apply_threshold_strategy", apply_threshold_strategy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if look_back_period_seconds is not None:
            pulumi.set(__self__, "look_back_period_seconds", look_back_period_seconds)
        if management_option is not None:
            pulumi.set(__self__, "management_option", management_option)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)

    @_builtins.property
    @pulumi.getter(name="applyThreshold")
    @_utilities.deprecated("""Use apply_threshold_strategy instead""")
    def apply_threshold(self) -> Optional[_builtins.float]:
        """
        The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
        """
        return pulumi.get(self, "apply_threshold")

    @_builtins.property
    @pulumi.getter(name="applyThresholdStrategy")
    def apply_threshold_strategy(self) -> Optional['outputs.WorkloadScalingPolicyMemoryApplyThresholdStrategy']:
        """
        Resource apply threshold strategy settings. The default strategy is `PERCENTAGE` with percentage value set to 0.1.
        """
        return pulumi.get(self, "apply_threshold_strategy")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[_builtins.str]:
        """
        The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.str]:
        """
        The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional['outputs.WorkloadScalingPolicyMemoryLimit']:
        """
        Resource limit settings
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="lookBackPeriodSeconds")
    def look_back_period_seconds(self) -> Optional[_builtins.int]:
        """
        The look back period in seconds for the recommendation.
        """
        return pulumi.get(self, "look_back_period_seconds")

    @_builtins.property
    @pulumi.getter(name="managementOption")
    def management_option(self) -> Optional[_builtins.str]:
        """
        Disables management for a single resource when set to `READ_ONLY`. The resource will use its original workload template requests and limits. Supported value: `READ_ONLY`. Minimum required workload-autoscaler version: `v0.23.1`.
        """
        return pulumi.get(self, "management_option")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def overhead(self) -> Optional[_builtins.float]:
        """
        Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
        """
        return pulumi.get(self, "overhead")


@pulumi.output_type
class WorkloadScalingPolicyMemoryApplyThresholdStrategy(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 denominator: Optional[_builtins.str] = None,
                 exponent: Optional[_builtins.float] = None,
                 numerator: Optional[_builtins.float] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.str type: Defines apply theshold strategy type.
               	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
                   - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
                   - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        :param _builtins.str denominator: If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param _builtins.float exponent: The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
               	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
               	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
               	It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param _builtins.float numerator: The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        :param _builtins.float percentage: Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        pulumi.set(__self__, "type", type)
        if denominator is not None:
            pulumi.set(__self__, "denominator", denominator)
        if exponent is not None:
            pulumi.set(__self__, "exponent", exponent)
        if numerator is not None:
            pulumi.set(__self__, "numerator", numerator)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Defines apply theshold strategy type.
        	- PERCENTAGE - recommendation will be applied when diff of current requests and new recommendation is greater than set value
            - DEFAULT_ADAPTIVE - will pick larger threshold percentage for small workloads and smaller percentage for large workloads.
            - CUSTOM_ADAPTIVE - works in same way as DEFAULT_ADAPTIVE, but it allows to tweak parameters of adaptive threshold formula: percentage = numerator/(currentRequest + denominator)^exponent. This strategy is for advance use cases, we recommend to use DEFAULT_ADAPTIVE strategy.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def denominator(self) -> Optional[_builtins.str]:
        """
        If denominator is close or equal to 0, the threshold will be much bigger for small values.For example when numerator, exponent is 1 and denominator is 0 the threshold for 0.5 req. CPU will be 200%.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "denominator")

    @_builtins.property
    @pulumi.getter
    def exponent(self) -> Optional[_builtins.float]:
        """
        The exponent changes how fast the curve is going down. The smaller value will cause that we won’t pick extremely small number for big resources, for example:
        	- if numerator is 0, denominator is 1, and exponent is 1, for 50 CPU we will pick 2% threshold
        	- if numerator is 0, denominator is 1, and exponent is 0.8, for 50 CPU we will pick 4.3% threshold
        	It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "exponent")

    @_builtins.property
    @pulumi.getter
    def numerator(self) -> Optional[_builtins.float]:
        """
        The numerator affects vertical stretch of function used in adaptive threshold - smaller number will create smaller threshold.It must be defined for the CUSTOM_ADAPTIVE strategy.
        """
        return pulumi.get(self, "numerator")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        Percentage of a how much difference should there be between the current pod requests and the new recommendation. It must be defined for the PERCENTAGE strategy.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class WorkloadScalingPolicyMemoryEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyType":
            suggest = "apply_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyMemoryEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyMemoryEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyMemoryEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_type: Defines the apply type to be used when applying recommendation for memory related event.
               	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
               	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        if apply_type is not None:
            pulumi.set(__self__, "apply_type", apply_type)

    @_builtins.property
    @pulumi.getter(name="applyType")
    def apply_type(self) -> Optional[_builtins.str]:
        """
        Defines the apply type to be used when applying recommendation for memory related event.
        	- IMMEDIATE - pods are restarted immediately when new recommendation is generated.
        	- DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
        """
        return pulumi.get(self, "apply_type")


@pulumi.output_type
class WorkloadScalingPolicyMemoryLimit(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 multiplier: Optional[_builtins.float] = None):
        """
        :param _builtins.str type: Defines limit strategy type.
               	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
               	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
               	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        :param _builtins.float multiplier: Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        pulumi.set(__self__, "type", type)
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Defines limit strategy type.
        	- NO_LIMIT - removes the resource limit even if it was specified in the workload spec.
        	- KEEP_LIMITS - keep existing resource limits. While limits provide stability predictability, they may restrict workloads that need to temporarily burst beyond their allocation.
        	- MULTIPLIER - used to calculate the resource limit. The final value is determined by multiplying the resource request by the specified factor.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def multiplier(self) -> Optional[_builtins.float]:
        """
        Multiplier used to calculate the resource limit. It must be defined for the MULTIPLIER strategy.
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class WorkloadScalingPolicyPredictiveScaling(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.WorkloadScalingPolicyPredictiveScalingCpu'] = None):
        """
        :param 'WorkloadScalingPolicyPredictiveScalingCpuArgs' cpu: Defines predictive scaling resource configuration.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.WorkloadScalingPolicyPredictiveScalingCpu']:
        """
        Defines predictive scaling resource configuration.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class WorkloadScalingPolicyPredictiveScalingCpu(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Defines if predictive scaling is enabled for resource.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Defines if predictive scaling is enabled for resource.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WorkloadScalingPolicyRolloutBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferOneByOne":
            suggest = "prefer_one_by_one"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyRolloutBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyRolloutBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyRolloutBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefer_one_by_one: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool prefer_one_by_one: Defines if pods should be restarted one by one to avoid service disruption.
        :param _builtins.str type: Defines the rollout type to be used when applying recommendations.
               	- NO_DISRUPTION - pods are restarted without causing service disruption.
        """
        if prefer_one_by_one is not None:
            pulumi.set(__self__, "prefer_one_by_one", prefer_one_by_one)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="preferOneByOne")
    def prefer_one_by_one(self) -> Optional[_builtins.bool]:
        """
        Defines if pods should be restarted one by one to avoid service disruption.
        """
        return pulumi.get(self, "prefer_one_by_one")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Defines the rollout type to be used when applying recommendations.
        	- NO_DISRUPTION - pods are restarted without causing service disruption.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WorkloadScalingPolicyStartup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "periodSeconds":
            suggest = "period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadScalingPolicyStartup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadScalingPolicyStartup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadScalingPolicyStartup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int period_seconds: Defines the duration (in seconds) during which elevated resource usage is expected at startup.
               When set, recommendations will be adjusted to disregard resource spikes within this period.
               If not specified, the workload will receive standard recommendations without startup considerations.
        """
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        Defines the duration (in seconds) during which elevated resource usage is expected at startup.
        When set, recommendations will be adjusted to disregard resource spikes within this period.
        If not specified, the workload will receive standard recommendations without startup considerations.
        """
        return pulumi.get(self, "period_seconds")


