# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CommitmentsAzureReservationArgs',
    'CommitmentsAzureReservationArgsDict',
    'CommitmentsAzureReservationAssignmentArgs',
    'CommitmentsAzureReservationAssignmentArgsDict',
    'CommitmentsCommitmentConfigArgs',
    'CommitmentsCommitmentConfigArgsDict',
    'CommitmentsCommitmentConfigAssignmentArgs',
    'CommitmentsCommitmentConfigAssignmentArgsDict',
    'CommitmentsCommitmentConfigMatcherArgs',
    'CommitmentsCommitmentConfigMatcherArgsDict',
    'CommitmentsGcpCudArgs',
    'CommitmentsGcpCudArgsDict',
    'CommitmentsGcpCudAssignmentArgs',
    'CommitmentsGcpCudAssignmentArgsDict',
    'ReservationsReservationArgs',
    'ReservationsReservationArgsDict',
]

MYPY = False

if not MYPY:
    class CommitmentsAzureReservationArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Number of instances covered by the reservation.
        """
        end_timestamp: pulumi.Input[_builtins.str]
        """
        End timestamp of the CUD.
        """
        instance_type: pulumi.Input[_builtins.str]
        """
        Type of the instance covered by the reservation.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the CUD.
        """
        plan: pulumi.Input[_builtins.str]
        """
        Plan of the reservation.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region in which the CUD is available.
        """
        reservation_id: pulumi.Input[_builtins.str]
        """
        ID of the reservation in Azure.
        """
        reservation_status: pulumi.Input[_builtins.str]
        """
        Status of the reservation in Azure.
        """
        scope: pulumi.Input[_builtins.str]
        scope_resource_group: pulumi.Input[_builtins.str]
        scope_subscription: pulumi.Input[_builtins.str]
        start_timestamp: pulumi.Input[_builtins.str]
        """
        Start timestamp of the CUD.
        """
        allowed_usage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        """
        assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['CommitmentsAzureReservationAssignmentArgsDict']]]]
        """
        List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the commitment in CAST AI.
        """
        prioritization: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, it's possible to assign priorities to the assigned clusters.
        """
        scaling_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the commitment in CAST AI.
        """
elif False:
    CommitmentsAzureReservationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsAzureReservationArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 end_timestamp: pulumi.Input[_builtins.str],
                 instance_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 plan: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 reservation_id: pulumi.Input[_builtins.str],
                 reservation_status: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str],
                 scope_resource_group: pulumi.Input[_builtins.str],
                 scope_subscription: pulumi.Input[_builtins.str],
                 start_timestamp: pulumi.Input[_builtins.str],
                 allowed_usage: Optional[pulumi.Input[_builtins.float]] = None,
                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsAzureReservationAssignmentArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prioritization: Optional[pulumi.Input[_builtins.bool]] = None,
                 scaling_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of instances covered by the reservation.
        :param pulumi.Input[_builtins.str] end_timestamp: End timestamp of the CUD.
        :param pulumi.Input[_builtins.str] instance_type: Type of the instance covered by the reservation.
        :param pulumi.Input[_builtins.str] name: Name of the CUD.
        :param pulumi.Input[_builtins.str] plan: Plan of the reservation.
        :param pulumi.Input[_builtins.str] region: Region in which the CUD is available.
        :param pulumi.Input[_builtins.str] reservation_id: ID of the reservation in Azure.
        :param pulumi.Input[_builtins.str] reservation_status: Status of the reservation in Azure.
        :param pulumi.Input[_builtins.str] start_timestamp: Start timestamp of the CUD.
        :param pulumi.Input[_builtins.float] allowed_usage: Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        :param pulumi.Input[Sequence[pulumi.Input['CommitmentsAzureReservationAssignmentArgs']]] assignments: List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        :param pulumi.Input[_builtins.str] id: ID of the commitment in CAST AI.
        :param pulumi.Input[_builtins.bool] prioritization: If enabled, it's possible to assign priorities to the assigned clusters.
        :param pulumi.Input[_builtins.str] scaling_strategy: Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        :param pulumi.Input[_builtins.str] status: Status of the commitment in CAST AI.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "end_timestamp", end_timestamp)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "reservation_id", reservation_id)
        pulumi.set(__self__, "reservation_status", reservation_status)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "scope_resource_group", scope_resource_group)
        pulumi.set(__self__, "scope_subscription", scope_subscription)
        pulumi.set(__self__, "start_timestamp", start_timestamp)
        if allowed_usage is not None:
            pulumi.set(__self__, "allowed_usage", allowed_usage)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prioritization is not None:
            pulumi.set(__self__, "prioritization", prioritization)
        if scaling_strategy is not None:
            pulumi.set(__self__, "scaling_strategy", scaling_strategy)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Number of instances covered by the reservation.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="endTimestamp")
    def end_timestamp(self) -> pulumi.Input[_builtins.str]:
        """
        End timestamp of the CUD.
        """
        return pulumi.get(self, "end_timestamp")

    @end_timestamp.setter
    def end_timestamp(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end_timestamp", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the instance covered by the reservation.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the CUD.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def plan(self) -> pulumi.Input[_builtins.str]:
        """
        Plan of the reservation.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plan", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region in which the CUD is available.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="reservationId")
    def reservation_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the reservation in Azure.
        """
        return pulumi.get(self, "reservation_id")

    @reservation_id.setter
    def reservation_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reservation_id", value)

    @_builtins.property
    @pulumi.getter(name="reservationStatus")
    def reservation_status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the reservation in Azure.
        """
        return pulumi.get(self, "reservation_status")

    @reservation_status.setter
    def reservation_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reservation_status", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="scopeResourceGroup")
    def scope_resource_group(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope_resource_group")

    @scope_resource_group.setter
    def scope_resource_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope_resource_group", value)

    @_builtins.property
    @pulumi.getter(name="scopeSubscription")
    def scope_subscription(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope_subscription")

    @scope_subscription.setter
    def scope_subscription(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope_subscription", value)

    @_builtins.property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> pulumi.Input[_builtins.str]:
        """
        Start timestamp of the CUD.
        """
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_timestamp", value)

    @_builtins.property
    @pulumi.getter(name="allowedUsage")
    def allowed_usage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        """
        return pulumi.get(self, "allowed_usage")

    @allowed_usage.setter
    def allowed_usage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "allowed_usage", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsAzureReservationAssignmentArgs']]]]:
        """
        List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsAzureReservationAssignmentArgs']]]]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the commitment in CAST AI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def prioritization(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, it's possible to assign priorities to the assigned clusters.
        """
        return pulumi.get(self, "prioritization")

    @prioritization.setter
    def prioritization(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prioritization", value)

    @_builtins.property
    @pulumi.getter(name="scalingStrategy")
    def scaling_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        """
        return pulumi.get(self, "scaling_strategy")

    @scaling_strategy.setter
    def scaling_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_strategy", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the commitment in CAST AI.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class CommitmentsAzureReservationAssignmentArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the cluster to assign the commitment to.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
elif False:
    CommitmentsAzureReservationAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsAzureReservationAssignmentArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: ID of the cluster to assign the commitment to.
        :param pulumi.Input[_builtins.int] priority: Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the cluster to assign the commitment to.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class CommitmentsCommitmentConfigArgsDict(TypedDict):
        matcher: pulumi.Input['CommitmentsCommitmentConfigMatcherArgsDict']
        """
        Matcher used to map config to a commitment.
        """
        allowed_usage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        """
        assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['CommitmentsCommitmentConfigAssignmentArgsDict']]]]
        """
        List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        """
        prioritization: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, it's possible to assign priorities to the assigned clusters.
        """
        scaling_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the commitment in CAST AI.
        """
elif False:
    CommitmentsCommitmentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsCommitmentConfigArgs:
    def __init__(__self__, *,
                 matcher: pulumi.Input['CommitmentsCommitmentConfigMatcherArgs'],
                 allowed_usage: Optional[pulumi.Input[_builtins.float]] = None,
                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsCommitmentConfigAssignmentArgs']]]] = None,
                 prioritization: Optional[pulumi.Input[_builtins.bool]] = None,
                 scaling_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CommitmentsCommitmentConfigMatcherArgs'] matcher: Matcher used to map config to a commitment.
        :param pulumi.Input[_builtins.float] allowed_usage: Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        :param pulumi.Input[Sequence[pulumi.Input['CommitmentsCommitmentConfigAssignmentArgs']]] assignments: List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        :param pulumi.Input[_builtins.bool] prioritization: If enabled, it's possible to assign priorities to the assigned clusters.
        :param pulumi.Input[_builtins.str] scaling_strategy: Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        :param pulumi.Input[_builtins.str] status: Status of the commitment in CAST AI.
        """
        pulumi.set(__self__, "matcher", matcher)
        if allowed_usage is not None:
            pulumi.set(__self__, "allowed_usage", allowed_usage)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if prioritization is not None:
            pulumi.set(__self__, "prioritization", prioritization)
        if scaling_strategy is not None:
            pulumi.set(__self__, "scaling_strategy", scaling_strategy)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def matcher(self) -> pulumi.Input['CommitmentsCommitmentConfigMatcherArgs']:
        """
        Matcher used to map config to a commitment.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: pulumi.Input['CommitmentsCommitmentConfigMatcherArgs']):
        pulumi.set(self, "matcher", value)

    @_builtins.property
    @pulumi.getter(name="allowedUsage")
    def allowed_usage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        """
        return pulumi.get(self, "allowed_usage")

    @allowed_usage.setter
    def allowed_usage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "allowed_usage", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsCommitmentConfigAssignmentArgs']]]]:
        """
        List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsCommitmentConfigAssignmentArgs']]]]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter
    def prioritization(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, it's possible to assign priorities to the assigned clusters.
        """
        return pulumi.get(self, "prioritization")

    @prioritization.setter
    def prioritization(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prioritization", value)

    @_builtins.property
    @pulumi.getter(name="scalingStrategy")
    def scaling_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        """
        return pulumi.get(self, "scaling_strategy")

    @scaling_strategy.setter
    def scaling_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_strategy", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the commitment in CAST AI.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class CommitmentsCommitmentConfigAssignmentArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        ID of the cluster to assign the commitment to.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
elif False:
    CommitmentsCommitmentConfigAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsCommitmentConfigAssignmentArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: ID of the cluster to assign the commitment to.
        :param pulumi.Input[_builtins.int] priority: Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the cluster to assign the commitment to.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class CommitmentsCommitmentConfigMatcherArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the commitment to match.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region of the commitment to match.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the commitment to match. For compute resources, it's the type of the machine.
        """
elif False:
    CommitmentsCommitmentConfigMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsCommitmentConfigMatcherArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the commitment to match.
        :param pulumi.Input[_builtins.str] region: Region of the commitment to match.
        :param pulumi.Input[_builtins.str] type: Type of the commitment to match. For compute resources, it's the type of the machine.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the commitment to match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region of the commitment to match.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the commitment to match. For compute resources, it's the type of the machine.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CommitmentsGcpCudArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.int]
        """
        Number of CPUs covered by the CUD.
        """
        cud_id: pulumi.Input[_builtins.str]
        """
        ID of the CUD in GCP.
        """
        cud_status: pulumi.Input[_builtins.str]
        """
        Status of the CUD in GCP.
        """
        end_timestamp: pulumi.Input[_builtins.str]
        """
        End timestamp of the CUD.
        """
        memory_mb: pulumi.Input[_builtins.int]
        """
        Amount of memory in MB covered by the CUD.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the CUD.
        """
        plan: pulumi.Input[_builtins.str]
        """
        CUD plan e.g. 'TWELVE_MONTH'.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region in which the CUD is available.
        """
        start_timestamp: pulumi.Input[_builtins.str]
        """
        Start timestamp of the CUD.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of the CUD, e.g. determines the covered resource type e.g. 'COMPUTE_OPTIMIZED_C2D'.
        """
        allowed_usage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        """
        assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['CommitmentsGcpCudAssignmentArgsDict']]]]
        """
        List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the commitment in CAST AI.
        """
        prioritization: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, it's possible to assign priorities to the assigned clusters.
        """
        scaling_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the commitment in CAST AI.
        """
elif False:
    CommitmentsGcpCudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsGcpCudArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.int],
                 cud_id: pulumi.Input[_builtins.str],
                 cud_status: pulumi.Input[_builtins.str],
                 end_timestamp: pulumi.Input[_builtins.str],
                 memory_mb: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 plan: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 start_timestamp: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 allowed_usage: Optional[pulumi.Input[_builtins.float]] = None,
                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsGcpCudAssignmentArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prioritization: Optional[pulumi.Input[_builtins.bool]] = None,
                 scaling_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu: Number of CPUs covered by the CUD.
        :param pulumi.Input[_builtins.str] cud_id: ID of the CUD in GCP.
        :param pulumi.Input[_builtins.str] cud_status: Status of the CUD in GCP.
        :param pulumi.Input[_builtins.str] end_timestamp: End timestamp of the CUD.
        :param pulumi.Input[_builtins.int] memory_mb: Amount of memory in MB covered by the CUD.
        :param pulumi.Input[_builtins.str] name: Name of the CUD.
        :param pulumi.Input[_builtins.str] plan: CUD plan e.g. 'TWELVE_MONTH'.
        :param pulumi.Input[_builtins.str] region: Region in which the CUD is available.
        :param pulumi.Input[_builtins.str] start_timestamp: Start timestamp of the CUD.
        :param pulumi.Input[_builtins.str] type: Type of the CUD, e.g. determines the covered resource type e.g. 'COMPUTE_OPTIMIZED_C2D'.
        :param pulumi.Input[_builtins.float] allowed_usage: Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        :param pulumi.Input[Sequence[pulumi.Input['CommitmentsGcpCudAssignmentArgs']]] assignments: List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        :param pulumi.Input[_builtins.str] id: ID of the commitment in CAST AI.
        :param pulumi.Input[_builtins.bool] prioritization: If enabled, it's possible to assign priorities to the assigned clusters.
        :param pulumi.Input[_builtins.str] scaling_strategy: Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        :param pulumi.Input[_builtins.str] status: Status of the commitment in CAST AI.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "cud_id", cud_id)
        pulumi.set(__self__, "cud_status", cud_status)
        pulumi.set(__self__, "end_timestamp", end_timestamp)
        pulumi.set(__self__, "memory_mb", memory_mb)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "start_timestamp", start_timestamp)
        pulumi.set(__self__, "type", type)
        if allowed_usage is not None:
            pulumi.set(__self__, "allowed_usage", allowed_usage)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prioritization is not None:
            pulumi.set(__self__, "prioritization", prioritization)
        if scaling_strategy is not None:
            pulumi.set(__self__, "scaling_strategy", scaling_strategy)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.int]:
        """
        Number of CPUs covered by the CUD.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="cudId")
    def cud_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the CUD in GCP.
        """
        return pulumi.get(self, "cud_id")

    @cud_id.setter
    def cud_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cud_id", value)

    @_builtins.property
    @pulumi.getter(name="cudStatus")
    def cud_status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the CUD in GCP.
        """
        return pulumi.get(self, "cud_status")

    @cud_status.setter
    def cud_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cud_status", value)

    @_builtins.property
    @pulumi.getter(name="endTimestamp")
    def end_timestamp(self) -> pulumi.Input[_builtins.str]:
        """
        End timestamp of the CUD.
        """
        return pulumi.get(self, "end_timestamp")

    @end_timestamp.setter
    def end_timestamp(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end_timestamp", value)

    @_builtins.property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> pulumi.Input[_builtins.int]:
        """
        Amount of memory in MB covered by the CUD.
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "memory_mb", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the CUD.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def plan(self) -> pulumi.Input[_builtins.str]:
        """
        CUD plan e.g. 'TWELVE_MONTH'.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plan", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region in which the CUD is available.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> pulumi.Input[_builtins.str]:
        """
        Start timestamp of the CUD.
        """
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_timestamp", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the CUD, e.g. determines the covered resource type e.g. 'COMPUTE_OPTIMIZED_C2D'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="allowedUsage")
    def allowed_usage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Allowed usage of the commitment. The value is between 0 (0%) and 1 (100%).
        """
        return pulumi.get(self, "allowed_usage")

    @allowed_usage.setter
    def allowed_usage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "allowed_usage", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsGcpCudAssignmentArgs']]]]:
        """
        List of assigned clusters for the commitment. If prioritization is enabled, the order of the assignments indicates the priority. The first assignment has the highest priority.
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CommitmentsGcpCudAssignmentArgs']]]]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the commitment in CAST AI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def prioritization(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, it's possible to assign priorities to the assigned clusters.
        """
        return pulumi.get(self, "prioritization")

    @prioritization.setter
    def prioritization(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prioritization", value)

    @_builtins.property
    @pulumi.getter(name="scalingStrategy")
    def scaling_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scaling strategy of the commitment in CAST AI. One of: Default, CPUBased, RamBased
        """
        return pulumi.get(self, "scaling_strategy")

    @scaling_strategy.setter
    def scaling_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_strategy", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the commitment in CAST AI.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class CommitmentsGcpCudAssignmentArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the cluster to assign the commitment to.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
elif False:
    CommitmentsGcpCudAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommitmentsGcpCudAssignmentArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: ID of the cluster to assign the commitment to.
        :param pulumi.Input[_builtins.int] priority: Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the cluster to assign the commitment to.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority of the assignment. The lower the value, the higher the priority. 1 is the highest priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ReservationsReservationArgsDict(TypedDict):
        count: pulumi.Input[_builtins.str]
        """
        amount of reserved instances
        """
        instance_type: pulumi.Input[_builtins.str]
        """
        reserved instance type
        """
        name: pulumi.Input[_builtins.str]
        """
        unique reservation name in region for specific instance type
        """
        price: pulumi.Input[_builtins.str]
        """
        reservation price
        """
        provider: pulumi.Input[_builtins.str]
        """
        reservation cloud provider (gcp, aws, azure)
        """
        region: pulumi.Input[_builtins.str]
        """
        reservation region
        """
        start_date: pulumi.Input[_builtins.str]
        """
        start date of reservation
        """
        end_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        end date of reservation
        """
        zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        reservation zone id
        """
        zone_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        reservation zone name
        """
elif False:
    ReservationsReservationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReservationsReservationArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.str],
                 instance_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 price: pulumi.Input[_builtins.str],
                 provider: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 start_date: pulumi.Input[_builtins.str],
                 end_date: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_id: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] count: amount of reserved instances
        :param pulumi.Input[_builtins.str] instance_type: reserved instance type
        :param pulumi.Input[_builtins.str] name: unique reservation name in region for specific instance type
        :param pulumi.Input[_builtins.str] price: reservation price
        :param pulumi.Input[_builtins.str] provider: reservation cloud provider (gcp, aws, azure)
        :param pulumi.Input[_builtins.str] region: reservation region
        :param pulumi.Input[_builtins.str] start_date: start date of reservation
        :param pulumi.Input[_builtins.str] end_date: end date of reservation
        :param pulumi.Input[_builtins.str] zone_id: reservation zone id
        :param pulumi.Input[_builtins.str] zone_name: reservation zone name
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "price", price)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.str]:
        """
        amount of reserved instances
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        """
        reserved instance type
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        unique reservation name in region for specific instance type
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def price(self) -> pulumi.Input[_builtins.str]:
        """
        reservation price
        """
        return pulumi.get(self, "price")

    @price.setter
    def price(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "price", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> pulumi.Input[_builtins.str]:
        """
        reservation cloud provider (gcp, aws, azure)
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        reservation region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[_builtins.str]:
        """
        start date of reservation
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_date", value)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        end date of reservation
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_date", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        reservation zone id
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_id", value)

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        reservation zone name
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_name", value)


