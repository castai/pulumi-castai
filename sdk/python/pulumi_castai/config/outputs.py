# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'NodeConfigurationAks',
    'NodeConfigurationAksEphemeralOsDisk',
    'NodeConfigurationAksLoadbalancer',
    'NodeConfigurationAksLoadbalancerIpBasedBackendPool',
    'NodeConfigurationAksLoadbalancerNicBasedBackendPool',
    'NodeConfigurationAksPublicIp',
    'NodeConfigurationEks',
    'NodeConfigurationEksTargetGroup',
    'NodeConfigurationGke',
    'NodeConfigurationGkeLoadbalancer',
    'NodeConfigurationGkeLoadbalancerTargetBackendPool',
    'NodeConfigurationGkeLoadbalancerUnmanagedInstanceGroup',
    'NodeConfigurationGkeSecondaryIpRange',
    'NodeConfigurationKops',
    'NodeTemplateConstraints',
    'NodeTemplateConstraintsCustomPriority',
    'NodeTemplateConstraintsDedicatedNodeAffinity',
    'NodeTemplateConstraintsDedicatedNodeAffinityAffinity',
    'NodeTemplateConstraintsGpu',
    'NodeTemplateConstraintsInstanceFamilies',
    'NodeTemplateConstraintsResourceLimits',
    'NodeTemplateCustomTaint',
    'NodeTemplateGpu',
    'NodeTemplateGpuSharingConfiguration',
]

@pulumi.output_type
class NodeConfigurationAks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aksImageFamily":
            suggest = "aks_image_family"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"
        elif key == "ephemeralOsDisk":
            suggest = "ephemeral_os_disk"
        elif key == "maxPodsPerNode":
            suggest = "max_pods_per_node"
        elif key == "networkSecurityGroup":
            suggest = "network_security_group"
        elif key == "osDiskType":
            suggest = "os_disk_type"
        elif key == "podSubnetId":
            suggest = "pod_subnet_id"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationAks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationAks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationAks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aks_image_family: Optional[_builtins.str] = None,
                 application_security_groups: Optional[Sequence[_builtins.str]] = None,
                 ephemeral_os_disk: Optional['outputs.NodeConfigurationAksEphemeralOsDisk'] = None,
                 loadbalancers: Optional[Sequence['outputs.NodeConfigurationAksLoadbalancer']] = None,
                 max_pods_per_node: Optional[_builtins.int] = None,
                 network_security_group: Optional[_builtins.str] = None,
                 os_disk_type: Optional[_builtins.str] = None,
                 pod_subnet_id: Optional[_builtins.str] = None,
                 public_ip: Optional['outputs.NodeConfigurationAksPublicIp'] = None):
        """
        :param _builtins.str aks_image_family: Image OS Family to use when provisioning node in AKS. If both image and family are provided, the system will use provided image and provisioning logic for given family. If only image family is provided, the system will attempt to resolve the latest image from that family based on kubernetes version and node architecture. If image family is omitted, a default family (based on cloud provider) will be used. See Cast.ai documentation for details. Possible values: (ubuntu,azure-linux,windows2019,windows2022)
        :param Sequence[_builtins.str] application_security_groups: Application security groups to be used for provisioned nodes
        :param 'NodeConfigurationAksEphemeralOsDiskArgs' ephemeral_os_disk: Ephemeral OS disk configuration for CAST provisioned nodes
        :param Sequence['NodeConfigurationAksLoadbalancerArgs'] loadbalancers: Load balancer configuration for CAST provisioned nodes
        :param _builtins.int max_pods_per_node: Maximum number of pods that can be run on a node, which affects how many IP addresses you will need for each node. Defaults to 30
        :param _builtins.str network_security_group: Network security group to be used for provisioned nodes, if not provided default security group from `castpool` will be used
        :param _builtins.str os_disk_type: Type of managed os disk attached to the node. (See [disk types](https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types)). One of: standard, standard-ssd, premium-ssd (ultra and premium-ssd-v2 are not supported for os disk)
        :param _builtins.str pod_subnet_id: ID of pod subnet to be used for provisioned nodes.
        :param 'NodeConfigurationAksPublicIpArgs' public_ip: Public IP configuration for CAST AI provisioned nodes
        """
        if aks_image_family is not None:
            pulumi.set(__self__, "aks_image_family", aks_image_family)
        if application_security_groups is not None:
            pulumi.set(__self__, "application_security_groups", application_security_groups)
        if ephemeral_os_disk is not None:
            pulumi.set(__self__, "ephemeral_os_disk", ephemeral_os_disk)
        if loadbalancers is not None:
            pulumi.set(__self__, "loadbalancers", loadbalancers)
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)
        if network_security_group is not None:
            pulumi.set(__self__, "network_security_group", network_security_group)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if pod_subnet_id is not None:
            pulumi.set(__self__, "pod_subnet_id", pod_subnet_id)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)

    @_builtins.property
    @pulumi.getter(name="aksImageFamily")
    def aks_image_family(self) -> Optional[_builtins.str]:
        """
        Image OS Family to use when provisioning node in AKS. If both image and family are provided, the system will use provided image and provisioning logic for given family. If only image family is provided, the system will attempt to resolve the latest image from that family based on kubernetes version and node architecture. If image family is omitted, a default family (based on cloud provider) will be used. See Cast.ai documentation for details. Possible values: (ubuntu,azure-linux,windows2019,windows2022)
        """
        return pulumi.get(self, "aks_image_family")

    @_builtins.property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Application security groups to be used for provisioned nodes
        """
        return pulumi.get(self, "application_security_groups")

    @_builtins.property
    @pulumi.getter(name="ephemeralOsDisk")
    def ephemeral_os_disk(self) -> Optional['outputs.NodeConfigurationAksEphemeralOsDisk']:
        """
        Ephemeral OS disk configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "ephemeral_os_disk")

    @_builtins.property
    @pulumi.getter
    def loadbalancers(self) -> Optional[Sequence['outputs.NodeConfigurationAksLoadbalancer']]:
        """
        Load balancer configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "loadbalancers")

    @_builtins.property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[_builtins.int]:
        """
        Maximum number of pods that can be run on a node, which affects how many IP addresses you will need for each node. Defaults to 30
        """
        return pulumi.get(self, "max_pods_per_node")

    @_builtins.property
    @pulumi.getter(name="networkSecurityGroup")
    def network_security_group(self) -> Optional[_builtins.str]:
        """
        Network security group to be used for provisioned nodes, if not provided default security group from `castpool` will be used
        """
        return pulumi.get(self, "network_security_group")

    @_builtins.property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[_builtins.str]:
        """
        Type of managed os disk attached to the node. (See [disk types](https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types)). One of: standard, standard-ssd, premium-ssd (ultra and premium-ssd-v2 are not supported for os disk)
        """
        return pulumi.get(self, "os_disk_type")

    @_builtins.property
    @pulumi.getter(name="podSubnetId")
    def pod_subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of pod subnet to be used for provisioned nodes.
        """
        return pulumi.get(self, "pod_subnet_id")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional['outputs.NodeConfigurationAksPublicIp']:
        """
        Public IP configuration for CAST AI provisioned nodes
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class NodeConfigurationAksEphemeralOsDisk(dict):
    def __init__(__self__, *,
                 placement: _builtins.str,
                 cache: Optional[_builtins.str] = None):
        """
        :param _builtins.str placement: Placement of the ephemeral OS disk. One of: cacheDisk, resourceDisk
        :param _builtins.str cache: Cache type for the ephemeral OS disk. One of: ReadOnly, ReadWrite
        """
        pulumi.set(__self__, "placement", placement)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> _builtins.str:
        """
        Placement of the ephemeral OS disk. One of: cacheDisk, resourceDisk
        """
        return pulumi.get(self, "placement")

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[_builtins.str]:
        """
        Cache type for the ephemeral OS disk. One of: ReadOnly, ReadWrite
        """
        return pulumi.get(self, "cache")


@pulumi.output_type
class NodeConfigurationAksLoadbalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipBasedBackendPools":
            suggest = "ip_based_backend_pools"
        elif key == "nicBasedBackendPools":
            suggest = "nic_based_backend_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationAksLoadbalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationAksLoadbalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationAksLoadbalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 ip_based_backend_pools: Optional[Sequence['outputs.NodeConfigurationAksLoadbalancerIpBasedBackendPool']] = None,
                 name: Optional[_builtins.str] = None,
                 nic_based_backend_pools: Optional[Sequence['outputs.NodeConfigurationAksLoadbalancerNicBasedBackendPool']] = None):
        """
        :param _builtins.str id: The full ID of the load balancer in azure.
        :param Sequence['NodeConfigurationAksLoadbalancerIpBasedBackendPoolArgs'] ip_based_backend_pools: IP based backend pools configuration for CAST provisioned nodes
        :param _builtins.str name: Name of load balancer
        :param Sequence['NodeConfigurationAksLoadbalancerNicBasedBackendPoolArgs'] nic_based_backend_pools: NIC based backend pools configuration for CAST provisioned nodes.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_based_backend_pools is not None:
            pulumi.set(__self__, "ip_based_backend_pools", ip_based_backend_pools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_based_backend_pools is not None:
            pulumi.set(__self__, "nic_based_backend_pools", nic_based_backend_pools)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The full ID of the load balancer in azure.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipBasedBackendPools")
    def ip_based_backend_pools(self) -> Optional[Sequence['outputs.NodeConfigurationAksLoadbalancerIpBasedBackendPool']]:
        """
        IP based backend pools configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "ip_based_backend_pools")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""name field is deprecated, use ID instead. Will be removed in future versions.""")
    def name(self) -> Optional[_builtins.str]:
        """
        Name of load balancer
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nicBasedBackendPools")
    def nic_based_backend_pools(self) -> Optional[Sequence['outputs.NodeConfigurationAksLoadbalancerNicBasedBackendPool']]:
        """
        NIC based backend pools configuration for CAST provisioned nodes.
        """
        return pulumi.get(self, "nic_based_backend_pools")


@pulumi.output_type
class NodeConfigurationAksLoadbalancerIpBasedBackendPool(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the ip based backend pool
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the ip based backend pool
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NodeConfigurationAksLoadbalancerNicBasedBackendPool(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the NIC based backend pool
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the NIC based backend pool
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NodeConfigurationAksPublicIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "publicIpPrefix":
            suggest = "public_ip_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationAksPublicIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationAksPublicIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationAksPublicIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_timeout_in_minutes: Optional[_builtins.int] = None,
                 public_ip_prefix: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int idle_timeout_in_minutes: Idle timeout in minutes for public IP
        :param _builtins.str public_ip_prefix: Public IP prefix to be used for provisioned nodes
        """
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if public_ip_prefix is not None:
            pulumi.set(__self__, "public_ip_prefix", public_ip_prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        Idle timeout in minutes for public IP
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="publicIpPrefix")
    def public_ip_prefix(self) -> Optional[_builtins.str]:
        """
        Public IP prefix to be used for provisioned nodes
        """
        return pulumi.get(self, "public_ip_prefix")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class NodeConfigurationEks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "dnsClusterIp":
            suggest = "dns_cluster_ip"
        elif key == "eksImageFamily":
            suggest = "eks_image_family"
        elif key == "imdsHopLimit":
            suggest = "imds_hop_limit"
        elif key == "imdsV1":
            suggest = "imds_v1"
        elif key == "ipsPerPrefix":
            suggest = "ips_per_prefix"
        elif key == "keyPairId":
            suggest = "key_pair_id"
        elif key == "maxPodsPerNodeFormula":
            suggest = "max_pods_per_node_formula"
        elif key == "nodeGroupArn":
            suggest = "node_group_arn"
        elif key == "targetGroups":
            suggest = "target_groups"
        elif key == "threadsPerCpu":
            suggest = "threads_per_cpu"
        elif key == "volumeIops":
            suggest = "volume_iops"
        elif key == "volumeKmsKeyArn":
            suggest = "volume_kms_key_arn"
        elif key == "volumeThroughput":
            suggest = "volume_throughput"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationEks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationEks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationEks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_profile_arn: _builtins.str,
                 security_groups: Sequence[_builtins.str],
                 dns_cluster_ip: Optional[_builtins.str] = None,
                 eks_image_family: Optional[_builtins.str] = None,
                 imds_hop_limit: Optional[_builtins.int] = None,
                 imds_v1: Optional[_builtins.bool] = None,
                 ips_per_prefix: Optional[_builtins.int] = None,
                 key_pair_id: Optional[_builtins.str] = None,
                 max_pods_per_node_formula: Optional[_builtins.str] = None,
                 node_group_arn: Optional[_builtins.str] = None,
                 target_groups: Optional[Sequence['outputs.NodeConfigurationEksTargetGroup']] = None,
                 threads_per_cpu: Optional[_builtins.int] = None,
                 volume_iops: Optional[_builtins.int] = None,
                 volume_kms_key_arn: Optional[_builtins.str] = None,
                 volume_throughput: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_profile_arn: Cluster's instance profile ARN used for CAST provisioned nodes
        :param Sequence[_builtins.str] security_groups: Cluster's security groups configuration for CAST provisioned nodes
        :param _builtins.str dns_cluster_ip: IP address to use for DNS queries within the cluster
        :param _builtins.str eks_image_family: Image OS Family to use when provisioning node in EKS. If both image and family are provided, the system will use provided image and provisioning logic for given family. If only image family is provided, the system will attempt to resolve the latest image from that family based on kubernetes version and node architecture. If image family is omitted, a default family (based on cloud provider) will be used. See Cast.ai documentation for details. Possible values: (al2,al2023,bottlerocket)
        :param _builtins.int imds_hop_limit: Allow configure the IMDSv2 hop limit, the default is 2
        :param _builtins.bool imds_v1: When the value is true both IMDSv1 and IMDSv2 are enabled. Setting the value to false disables permanently IMDSv1 and might affect legacy workloads running on the node created with this configuration. The default is true if the flag isn't provided
        :param _builtins.int ips_per_prefix: Number of IPs per prefix to be used for calculating max pods.
        :param _builtins.str key_pair_id: AWS key pair ID to be used for CAST provisioned nodes. Has priority over ssh_public_key
        :param _builtins.str max_pods_per_node_formula: Formula to calculate the maximum number of pods that can be run on a node. The following list of variables will be bound to a number before evaluating and can be used in the formula: NUM_MAX_NET_INTERFACES, NUM_IP_PER_INTERFACE, NUM_IP_PER_PREFIX, NUM_CPU, NUM_RAM_GB .
        :param _builtins.str node_group_arn: Cluster's node group ARN used for CAST provisioned node pools. Required for hibernate/resume functionality
        :param Sequence['NodeConfigurationEksTargetGroupArgs'] target_groups: AWS target groups configuration for CAST provisioned nodes
        :param _builtins.int threads_per_cpu: Number of threads per core.
        :param _builtins.int volume_iops: AWS EBS volume IOPS to be used for CAST provisioned nodes
        :param _builtins.str volume_kms_key_arn: AWS KMS key ARN for encrypting EBS volume attached to the node
        :param _builtins.int volume_throughput: AWS EBS volume throughput in MiB/s to be used for CAST provisioned nodes
        :param _builtins.str volume_type: AWS EBS volume type to be used for CAST provisioned nodes. One of: gp3, gp2, io1, io2
        """
        pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        pulumi.set(__self__, "security_groups", security_groups)
        if dns_cluster_ip is not None:
            pulumi.set(__self__, "dns_cluster_ip", dns_cluster_ip)
        if eks_image_family is not None:
            pulumi.set(__self__, "eks_image_family", eks_image_family)
        if imds_hop_limit is not None:
            pulumi.set(__self__, "imds_hop_limit", imds_hop_limit)
        if imds_v1 is not None:
            pulumi.set(__self__, "imds_v1", imds_v1)
        if ips_per_prefix is not None:
            pulumi.set(__self__, "ips_per_prefix", ips_per_prefix)
        if key_pair_id is not None:
            pulumi.set(__self__, "key_pair_id", key_pair_id)
        if max_pods_per_node_formula is not None:
            pulumi.set(__self__, "max_pods_per_node_formula", max_pods_per_node_formula)
        if node_group_arn is not None:
            pulumi.set(__self__, "node_group_arn", node_group_arn)
        if target_groups is not None:
            pulumi.set(__self__, "target_groups", target_groups)
        if threads_per_cpu is not None:
            pulumi.set(__self__, "threads_per_cpu", threads_per_cpu)
        if volume_iops is not None:
            pulumi.set(__self__, "volume_iops", volume_iops)
        if volume_kms_key_arn is not None:
            pulumi.set(__self__, "volume_kms_key_arn", volume_kms_key_arn)
        if volume_throughput is not None:
            pulumi.set(__self__, "volume_throughput", volume_throughput)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> _builtins.str:
        """
        Cluster's instance profile ARN used for CAST provisioned nodes
        """
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        """
        Cluster's security groups configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="dnsClusterIp")
    def dns_cluster_ip(self) -> Optional[_builtins.str]:
        """
        IP address to use for DNS queries within the cluster
        """
        return pulumi.get(self, "dns_cluster_ip")

    @_builtins.property
    @pulumi.getter(name="eksImageFamily")
    def eks_image_family(self) -> Optional[_builtins.str]:
        """
        Image OS Family to use when provisioning node in EKS. If both image and family are provided, the system will use provided image and provisioning logic for given family. If only image family is provided, the system will attempt to resolve the latest image from that family based on kubernetes version and node architecture. If image family is omitted, a default family (based on cloud provider) will be used. See Cast.ai documentation for details. Possible values: (al2,al2023,bottlerocket)
        """
        return pulumi.get(self, "eks_image_family")

    @_builtins.property
    @pulumi.getter(name="imdsHopLimit")
    def imds_hop_limit(self) -> Optional[_builtins.int]:
        """
        Allow configure the IMDSv2 hop limit, the default is 2
        """
        return pulumi.get(self, "imds_hop_limit")

    @_builtins.property
    @pulumi.getter(name="imdsV1")
    def imds_v1(self) -> Optional[_builtins.bool]:
        """
        When the value is true both IMDSv1 and IMDSv2 are enabled. Setting the value to false disables permanently IMDSv1 and might affect legacy workloads running on the node created with this configuration. The default is true if the flag isn't provided
        """
        return pulumi.get(self, "imds_v1")

    @_builtins.property
    @pulumi.getter(name="ipsPerPrefix")
    def ips_per_prefix(self) -> Optional[_builtins.int]:
        """
        Number of IPs per prefix to be used for calculating max pods.
        """
        return pulumi.get(self, "ips_per_prefix")

    @_builtins.property
    @pulumi.getter(name="keyPairId")
    def key_pair_id(self) -> Optional[_builtins.str]:
        """
        AWS key pair ID to be used for CAST provisioned nodes. Has priority over ssh_public_key
        """
        return pulumi.get(self, "key_pair_id")

    @_builtins.property
    @pulumi.getter(name="maxPodsPerNodeFormula")
    def max_pods_per_node_formula(self) -> Optional[_builtins.str]:
        """
        Formula to calculate the maximum number of pods that can be run on a node. The following list of variables will be bound to a number before evaluating and can be used in the formula: NUM_MAX_NET_INTERFACES, NUM_IP_PER_INTERFACE, NUM_IP_PER_PREFIX, NUM_CPU, NUM_RAM_GB .
        """
        return pulumi.get(self, "max_pods_per_node_formula")

    @_builtins.property
    @pulumi.getter(name="nodeGroupArn")
    def node_group_arn(self) -> Optional[_builtins.str]:
        """
        Cluster's node group ARN used for CAST provisioned node pools. Required for hibernate/resume functionality
        """
        return pulumi.get(self, "node_group_arn")

    @_builtins.property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Optional[Sequence['outputs.NodeConfigurationEksTargetGroup']]:
        """
        AWS target groups configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "target_groups")

    @_builtins.property
    @pulumi.getter(name="threadsPerCpu")
    def threads_per_cpu(self) -> Optional[_builtins.int]:
        """
        Number of threads per core.
        """
        return pulumi.get(self, "threads_per_cpu")

    @_builtins.property
    @pulumi.getter(name="volumeIops")
    def volume_iops(self) -> Optional[_builtins.int]:
        """
        AWS EBS volume IOPS to be used for CAST provisioned nodes
        """
        return pulumi.get(self, "volume_iops")

    @_builtins.property
    @pulumi.getter(name="volumeKmsKeyArn")
    def volume_kms_key_arn(self) -> Optional[_builtins.str]:
        """
        AWS KMS key ARN for encrypting EBS volume attached to the node
        """
        return pulumi.get(self, "volume_kms_key_arn")

    @_builtins.property
    @pulumi.getter(name="volumeThroughput")
    def volume_throughput(self) -> Optional[_builtins.int]:
        """
        AWS EBS volume throughput in MiB/s to be used for CAST provisioned nodes
        """
        return pulumi.get(self, "volume_throughput")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        AWS EBS volume type to be used for CAST provisioned nodes. One of: gp3, gp2, io1, io2
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class NodeConfigurationEksTargetGroup(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str arn: AWS target group ARN for CAST provisioned nodes
        :param _builtins.int port: Port for AWS target group for CAST provisioned nodes
        """
        pulumi.set(__self__, "arn", arn)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        AWS target group ARN for CAST provisioned nodes
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for AWS target group for CAST provisioned nodes
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class NodeConfigurationGke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "maxPodsPerNode":
            suggest = "max_pods_per_node"
        elif key == "maxPodsPerNodeFormula":
            suggest = "max_pods_per_node_formula"
        elif key == "networkTags":
            suggest = "network_tags"
        elif key == "onHostMaintenance":
            suggest = "on_host_maintenance"
        elif key == "secondaryIpRange":
            suggest = "secondary_ip_range"
        elif key == "useEphemeralStorageLocalSsd":
            suggest = "use_ephemeral_storage_local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationGke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationGke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationGke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: Optional[_builtins.str] = None,
                 loadbalancers: Optional[Sequence['outputs.NodeConfigurationGkeLoadbalancer']] = None,
                 max_pods_per_node: Optional[_builtins.int] = None,
                 max_pods_per_node_formula: Optional[_builtins.str] = None,
                 network_tags: Optional[Sequence[_builtins.str]] = None,
                 on_host_maintenance: Optional[_builtins.str] = None,
                 secondary_ip_range: Optional['outputs.NodeConfigurationGkeSecondaryIpRange'] = None,
                 use_ephemeral_storage_local_ssd: Optional[_builtins.bool] = None,
                 zones: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str disk_type: Type of boot disk attached to the node. (See [disk types](https://cloud.google.com/compute/docs/disks#pdspecs)). One of: pd-standard, pd-balanced, pd-ssd, pd-extreme
        :param Sequence['NodeConfigurationGkeLoadbalancerArgs'] loadbalancers: Loadboalancer configuration for CAST provisioned nodes
        :param _builtins.int max_pods_per_node: Maximum number of pods that can be run on a node, which affects how many IP addresses you will need for each node. Defaults to 110
        :param _builtins.str max_pods_per_node_formula: This is an advanced configuration field. In general, we recommend using max_pods_per_node instead.
               This field accepts a formula to calculate the maximum number of pods that can run on a node. This will affect the pod CIDR range that the node reserves. The following variables are available for use in the formula and will be bound to numeric values before evaluation:
               
                   * NUM_CPU - Number of CPUs available on the node
                   * NUM_RAM_GB - Amount of RAM in gigabytes available on the node.
               
               If you want the smallest value between 5 times the CPUs, 5 times the RAM, or a cap of 110, your formula would be math.least(110, 5 \\* NUM_CPU, 5 \\* NUM_RAM_GB).
               For a node with 8 CPUs and 16 GB RAM, this calculates to 40 (5×8), 80 (5×16), and 110, then picks the smallest value: 40 pods.
        :param Sequence[_builtins.str] network_tags: Network tags to be added on a VM. (See [network tags](https://cloud.google.com/vpc/docs/add-remove-network-tags))
        :param _builtins.str on_host_maintenance: Maintenance behavior of the instances. If not set, the default value for spot nodes is terminate, and for non-spot nodes, it is migrate.
        :param 'NodeConfigurationGkeSecondaryIpRangeArgs' secondary_ip_range: Secondary IP range configuration for pods in GKE nodes
        :param _builtins.bool use_ephemeral_storage_local_ssd: Use ephemeral storage local SSD. Defaults to false
        :param Sequence[_builtins.str] zones: List of preferred availability zones to choose from when provisioning new nodes.
        """
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if loadbalancers is not None:
            pulumi.set(__self__, "loadbalancers", loadbalancers)
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)
        if max_pods_per_node_formula is not None:
            pulumi.set(__self__, "max_pods_per_node_formula", max_pods_per_node_formula)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if secondary_ip_range is not None:
            pulumi.set(__self__, "secondary_ip_range", secondary_ip_range)
        if use_ephemeral_storage_local_ssd is not None:
            pulumi.set(__self__, "use_ephemeral_storage_local_ssd", use_ephemeral_storage_local_ssd)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Type of boot disk attached to the node. (See [disk types](https://cloud.google.com/compute/docs/disks#pdspecs)). One of: pd-standard, pd-balanced, pd-ssd, pd-extreme
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def loadbalancers(self) -> Optional[Sequence['outputs.NodeConfigurationGkeLoadbalancer']]:
        """
        Loadboalancer configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "loadbalancers")

    @_builtins.property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[_builtins.int]:
        """
        Maximum number of pods that can be run on a node, which affects how many IP addresses you will need for each node. Defaults to 110
        """
        return pulumi.get(self, "max_pods_per_node")

    @_builtins.property
    @pulumi.getter(name="maxPodsPerNodeFormula")
    def max_pods_per_node_formula(self) -> Optional[_builtins.str]:
        """
        This is an advanced configuration field. In general, we recommend using max_pods_per_node instead.
        This field accepts a formula to calculate the maximum number of pods that can run on a node. This will affect the pod CIDR range that the node reserves. The following variables are available for use in the formula and will be bound to numeric values before evaluation:

            * NUM_CPU - Number of CPUs available on the node
            * NUM_RAM_GB - Amount of RAM in gigabytes available on the node.

        If you want the smallest value between 5 times the CPUs, 5 times the RAM, or a cap of 110, your formula would be math.least(110, 5 \\* NUM_CPU, 5 \\* NUM_RAM_GB).
        For a node with 8 CPUs and 16 GB RAM, this calculates to 40 (5×8), 80 (5×16), and 110, then picks the smallest value: 40 pods.
        """
        return pulumi.get(self, "max_pods_per_node_formula")

    @_builtins.property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Network tags to be added on a VM. (See [network tags](https://cloud.google.com/vpc/docs/add-remove-network-tags))
        """
        return pulumi.get(self, "network_tags")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[_builtins.str]:
        """
        Maintenance behavior of the instances. If not set, the default value for spot nodes is terminate, and for non-spot nodes, it is migrate.
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="secondaryIpRange")
    def secondary_ip_range(self) -> Optional['outputs.NodeConfigurationGkeSecondaryIpRange']:
        """
        Secondary IP range configuration for pods in GKE nodes
        """
        return pulumi.get(self, "secondary_ip_range")

    @_builtins.property
    @pulumi.getter(name="useEphemeralStorageLocalSsd")
    def use_ephemeral_storage_local_ssd(self) -> Optional[_builtins.bool]:
        """
        Use ephemeral storage local SSD. Defaults to false
        """
        return pulumi.get(self, "use_ephemeral_storage_local_ssd")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The argument will be moved into node template.""")
    def zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of preferred availability zones to choose from when provisioning new nodes.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class NodeConfigurationGkeLoadbalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetBackendPools":
            suggest = "target_backend_pools"
        elif key == "unmanagedInstanceGroups":
            suggest = "unmanaged_instance_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationGkeLoadbalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationGkeLoadbalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationGkeLoadbalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_backend_pools: Optional[Sequence['outputs.NodeConfigurationGkeLoadbalancerTargetBackendPool']] = None,
                 unmanaged_instance_groups: Optional[Sequence['outputs.NodeConfigurationGkeLoadbalancerUnmanagedInstanceGroup']] = None):
        """
        :param Sequence['NodeConfigurationGkeLoadbalancerTargetBackendPoolArgs'] target_backend_pools: Target backend pools configuration for CAST provisioned nodes
        :param Sequence['NodeConfigurationGkeLoadbalancerUnmanagedInstanceGroupArgs'] unmanaged_instance_groups: Unmanaged instance groups configuration for CAST provisioned nodes
        """
        if target_backend_pools is not None:
            pulumi.set(__self__, "target_backend_pools", target_backend_pools)
        if unmanaged_instance_groups is not None:
            pulumi.set(__self__, "unmanaged_instance_groups", unmanaged_instance_groups)

    @_builtins.property
    @pulumi.getter(name="targetBackendPools")
    def target_backend_pools(self) -> Optional[Sequence['outputs.NodeConfigurationGkeLoadbalancerTargetBackendPool']]:
        """
        Target backend pools configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "target_backend_pools")

    @_builtins.property
    @pulumi.getter(name="unmanagedInstanceGroups")
    def unmanaged_instance_groups(self) -> Optional[Sequence['outputs.NodeConfigurationGkeLoadbalancerUnmanagedInstanceGroup']]:
        """
        Unmanaged instance groups configuration for CAST provisioned nodes
        """
        return pulumi.get(self, "unmanaged_instance_groups")


@pulumi.output_type
class NodeConfigurationGkeLoadbalancerTargetBackendPool(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the target group
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the target group
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NodeConfigurationGkeLoadbalancerUnmanagedInstanceGroup(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 zone: _builtins.str):
        """
        :param _builtins.str name: Name of the instance group
        :param _builtins.str zone: Zone of the instance group
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the instance group
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Zone of the instance group
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class NodeConfigurationGkeSecondaryIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationGkeSecondaryIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationGkeSecondaryIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationGkeSecondaryIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: _builtins.str):
        """
        :param _builtins.str range_name: Name of the secondary IP range
        """
        pulumi.set(__self__, "range_name", range_name)

    @_builtins.property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> _builtins.str:
        """
        Name of the secondary IP range
        """
        return pulumi.get(self, "range_name")


@pulumi.output_type
class NodeConfigurationKops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPairId":
            suggest = "key_pair_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigurationKops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigurationKops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigurationKops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_pair_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_pair_id: AWS key pair ID to be used for provisioned nodes. Has priority over sshPublicKey
        """
        if key_pair_id is not None:
            pulumi.set(__self__, "key_pair_id", key_pair_id)

    @_builtins.property
    @pulumi.getter(name="keyPairId")
    def key_pair_id(self) -> Optional[_builtins.str]:
        """
        AWS key pair ID to be used for provisioned nodes. Has priority over sshPublicKey
        """
        return pulumi.get(self, "key_pair_id")


@pulumi.output_type
class NodeTemplateConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "architecturePriorities":
            suggest = "architecture_priorities"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "burstableInstances":
            suggest = "burstable_instances"
        elif key == "computeOptimized":
            suggest = "compute_optimized"
        elif key == "computeOptimizedState":
            suggest = "compute_optimized_state"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "customPriorities":
            suggest = "custom_priorities"
        elif key == "customerSpecific":
            suggest = "customer_specific"
        elif key == "dedicatedNodeAffinities":
            suggest = "dedicated_node_affinities"
        elif key == "enableSpotDiversity":
            suggest = "enable_spot_diversity"
        elif key == "fallbackRestoreRateSeconds":
            suggest = "fallback_restore_rate_seconds"
        elif key == "instanceFamilies":
            suggest = "instance_families"
        elif key == "isGpuOnly":
            suggest = "is_gpu_only"
        elif key == "maxCpu":
            suggest = "max_cpu"
        elif key == "maxMemory":
            suggest = "max_memory"
        elif key == "minCpu":
            suggest = "min_cpu"
        elif key == "minMemory":
            suggest = "min_memory"
        elif key == "onDemand":
            suggest = "on_demand"
        elif key == "resourceLimits":
            suggest = "resource_limits"
        elif key == "spotDiversityPriceIncreaseLimitPercent":
            suggest = "spot_diversity_price_increase_limit_percent"
        elif key == "spotInterruptionPredictionsEnabled":
            suggest = "spot_interruption_predictions_enabled"
        elif key == "spotInterruptionPredictionsType":
            suggest = "spot_interruption_predictions_type"
        elif key == "spotReliabilityEnabled":
            suggest = "spot_reliability_enabled"
        elif key == "spotReliabilityPriceIncreaseLimitPercent":
            suggest = "spot_reliability_price_increase_limit_percent"
        elif key == "storageOptimized":
            suggest = "storage_optimized"
        elif key == "storageOptimizedState":
            suggest = "storage_optimized_state"
        elif key == "useSpotFallbacks":
            suggest = "use_spot_fallbacks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture_priorities: Optional[Sequence[_builtins.str]] = None,
                 architectures: Optional[Sequence[_builtins.str]] = None,
                 azs: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 burstable_instances: Optional[_builtins.str] = None,
                 compute_optimized: Optional[_builtins.bool] = None,
                 compute_optimized_state: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 custom_priorities: Optional[Sequence['outputs.NodeTemplateConstraintsCustomPriority']] = None,
                 customer_specific: Optional[_builtins.str] = None,
                 dedicated_node_affinities: Optional[Sequence['outputs.NodeTemplateConstraintsDedicatedNodeAffinity']] = None,
                 enable_spot_diversity: Optional[_builtins.bool] = None,
                 fallback_restore_rate_seconds: Optional[_builtins.int] = None,
                 gpu: Optional['outputs.NodeTemplateConstraintsGpu'] = None,
                 instance_families: Optional['outputs.NodeTemplateConstraintsInstanceFamilies'] = None,
                 is_gpu_only: Optional[_builtins.bool] = None,
                 max_cpu: Optional[_builtins.int] = None,
                 max_memory: Optional[_builtins.int] = None,
                 min_cpu: Optional[_builtins.int] = None,
                 min_memory: Optional[_builtins.int] = None,
                 on_demand: Optional[_builtins.bool] = None,
                 os: Optional[Sequence[_builtins.str]] = None,
                 resource_limits: Optional['outputs.NodeTemplateConstraintsResourceLimits'] = None,
                 spot: Optional[_builtins.bool] = None,
                 spot_diversity_price_increase_limit_percent: Optional[_builtins.int] = None,
                 spot_interruption_predictions_enabled: Optional[_builtins.bool] = None,
                 spot_interruption_predictions_type: Optional[_builtins.str] = None,
                 spot_reliability_enabled: Optional[_builtins.bool] = None,
                 spot_reliability_price_increase_limit_percent: Optional[_builtins.int] = None,
                 storage_optimized: Optional[_builtins.bool] = None,
                 storage_optimized_state: Optional[_builtins.str] = None,
                 use_spot_fallbacks: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] architecture_priorities: Priority ordering of architectures, specifying no priority will pick cheapest. Allowed values: amd64, arm64.
        :param Sequence[_builtins.str] architectures: List of acceptable instance CPU architectures, the default is amd64. Allowed values: amd64, arm64.
        :param Sequence[_builtins.str] azs: The list of AZ names to consider for the node template, if empty or not set all AZs are considered.
        :param _builtins.str bare_metal: Bare metal constraint, will only pick bare metal nodes if set to true. Will only pick non-bare metal nodes if false. Defaults to unspecified. Allowed values: true, false, unspecified.
        :param _builtins.str burstable_instances: Will include burstable instances when enabled otherwise they will be excluded. Supported values: `enabled`, `disabled` or ``.
        :param _builtins.bool compute_optimized: Compute optimized instance constraint (deprecated).
        :param _builtins.str compute_optimized_state: Will only include compute optimized nodes when enabled and exclude compute optimized nodes when disabled. Empty value won't have effect on instances filter. Supported values: `enabled`, `disabled` or empty string.
        :param Sequence[_builtins.str] cpu_manufacturers: List of acceptable CPU manufacturers. Allowed values: AMD, AMPERE, APPLE, AWS, INTEL.
        :param _builtins.str customer_specific: Will include customer specific (preview) instances when enabled otherwise they will be excluded. Supported values: `enabled`, `disabled` or ``.
        :param Sequence['NodeTemplateConstraintsDedicatedNodeAffinityArgs'] dedicated_node_affinities: Dedicated node affinity - creates preference for instances to be created on sole tenancy or dedicated nodes. This
                feature is only available for GCP clusters and sole tenancy nodes with local
                SSDs or GPUs are not supported. If the sole tenancy or dedicated nodes don't have capacity for selected instance
                type, the Autoscaler will fall back to multi-tenant instance types available for this Node Template.
                Other instance constraints are applied when the Autoscaler picks available instance types that can be created on
                the sole tenancy or dedicated node (example: setting min CPU to 16).
        :param _builtins.bool enable_spot_diversity: Enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        :param _builtins.int fallback_restore_rate_seconds: Fallback restore rate in seconds: defines how much time should pass before spot fallback should be attempted to be restored to real spot.
        :param _builtins.bool is_gpu_only: GPU instance constraint - will only pick nodes with GPU if true
        :param _builtins.int max_cpu: Max CPU cores per node.
        :param _builtins.int max_memory: Max Memory (Mib) per node.
        :param _builtins.int min_cpu: Min CPU cores per node.
        :param _builtins.int min_memory: Min Memory (Mib) per node.
        :param _builtins.bool on_demand: Should include on-demand instances in the considered pool.
        :param Sequence[_builtins.str] os: List of acceptable instance Operating Systems, the default is linux. Allowed values: linux, windows.
        :param _builtins.bool spot: Should include spot instances in the considered pool.
        :param _builtins.int spot_diversity_price_increase_limit_percent: Allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        :param _builtins.bool spot_interruption_predictions_enabled: Enable/disable spot interruption predictions.
        :param _builtins.str spot_interruption_predictions_type: Spot interruption predictions type. Can be either "aws-rebalance-recommendations" or "interruption-predictions".
        :param _builtins.bool spot_reliability_enabled: Enable/disable spot reliability. When enabled, autoscaler will create instances with highest reliability score within price increase threshold.
        :param _builtins.int spot_reliability_price_increase_limit_percent: Allowed node price increase when using spot reliability on ordering the instance types . E.g. if the value is 10%, then the overall price of instance types can be 10% higher than the price of the optimal configuration.
        :param _builtins.bool storage_optimized: Storage optimized instance constraint (deprecated).
        :param _builtins.str storage_optimized_state: Storage optimized instance constraint - will only pick storage optimized nodes if enabled and won't pick if disabled. Empty value will have no effect. Supported values: `enabled`, `disabled` or empty string.
        :param _builtins.bool use_spot_fallbacks: Spot instance fallback constraint - when true, on-demand instances will be created, when spots are unavailable.
        """
        if architecture_priorities is not None:
            pulumi.set(__self__, "architecture_priorities", architecture_priorities)
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if azs is not None:
            pulumi.set(__self__, "azs", azs)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if burstable_instances is not None:
            pulumi.set(__self__, "burstable_instances", burstable_instances)
        if compute_optimized is not None:
            pulumi.set(__self__, "compute_optimized", compute_optimized)
        if compute_optimized_state is not None:
            pulumi.set(__self__, "compute_optimized_state", compute_optimized_state)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if custom_priorities is not None:
            pulumi.set(__self__, "custom_priorities", custom_priorities)
        if customer_specific is not None:
            pulumi.set(__self__, "customer_specific", customer_specific)
        if dedicated_node_affinities is not None:
            pulumi.set(__self__, "dedicated_node_affinities", dedicated_node_affinities)
        if enable_spot_diversity is not None:
            pulumi.set(__self__, "enable_spot_diversity", enable_spot_diversity)
        if fallback_restore_rate_seconds is not None:
            pulumi.set(__self__, "fallback_restore_rate_seconds", fallback_restore_rate_seconds)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if instance_families is not None:
            pulumi.set(__self__, "instance_families", instance_families)
        if is_gpu_only is not None:
            pulumi.set(__self__, "is_gpu_only", is_gpu_only)
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)
        if spot is not None:
            pulumi.set(__self__, "spot", spot)
        if spot_diversity_price_increase_limit_percent is not None:
            pulumi.set(__self__, "spot_diversity_price_increase_limit_percent", spot_diversity_price_increase_limit_percent)
        if spot_interruption_predictions_enabled is not None:
            pulumi.set(__self__, "spot_interruption_predictions_enabled", spot_interruption_predictions_enabled)
        if spot_interruption_predictions_type is not None:
            pulumi.set(__self__, "spot_interruption_predictions_type", spot_interruption_predictions_type)
        if spot_reliability_enabled is not None:
            pulumi.set(__self__, "spot_reliability_enabled", spot_reliability_enabled)
        if spot_reliability_price_increase_limit_percent is not None:
            pulumi.set(__self__, "spot_reliability_price_increase_limit_percent", spot_reliability_price_increase_limit_percent)
        if storage_optimized is not None:
            pulumi.set(__self__, "storage_optimized", storage_optimized)
        if storage_optimized_state is not None:
            pulumi.set(__self__, "storage_optimized_state", storage_optimized_state)
        if use_spot_fallbacks is not None:
            pulumi.set(__self__, "use_spot_fallbacks", use_spot_fallbacks)

    @_builtins.property
    @pulumi.getter(name="architecturePriorities")
    def architecture_priorities(self) -> Optional[Sequence[_builtins.str]]:
        """
        Priority ordering of architectures, specifying no priority will pick cheapest. Allowed values: amd64, arm64.
        """
        return pulumi.get(self, "architecture_priorities")

    @_builtins.property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of acceptable instance CPU architectures, the default is amd64. Allowed values: amd64, arm64.
        """
        return pulumi.get(self, "architectures")

    @_builtins.property
    @pulumi.getter
    def azs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of AZ names to consider for the node template, if empty or not set all AZs are considered.
        """
        return pulumi.get(self, "azs")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        """
        Bare metal constraint, will only pick bare metal nodes if set to true. Will only pick non-bare metal nodes if false. Defaults to unspecified. Allowed values: true, false, unspecified.
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="burstableInstances")
    def burstable_instances(self) -> Optional[_builtins.str]:
        """
        Will include burstable instances when enabled otherwise they will be excluded. Supported values: `enabled`, `disabled` or ``.
        """
        return pulumi.get(self, "burstable_instances")

    @_builtins.property
    @pulumi.getter(name="computeOptimized")
    def compute_optimized(self) -> Optional[_builtins.bool]:
        """
        Compute optimized instance constraint (deprecated).
        """
        return pulumi.get(self, "compute_optimized")

    @_builtins.property
    @pulumi.getter(name="computeOptimizedState")
    def compute_optimized_state(self) -> Optional[_builtins.str]:
        """
        Will only include compute optimized nodes when enabled and exclude compute optimized nodes when disabled. Empty value won't have effect on instances filter. Supported values: `enabled`, `disabled` or empty string.
        """
        return pulumi.get(self, "compute_optimized_state")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of acceptable CPU manufacturers. Allowed values: AMD, AMPERE, APPLE, AWS, INTEL.
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="customPriorities")
    def custom_priorities(self) -> Optional[Sequence['outputs.NodeTemplateConstraintsCustomPriority']]:
        return pulumi.get(self, "custom_priorities")

    @_builtins.property
    @pulumi.getter(name="customerSpecific")
    def customer_specific(self) -> Optional[_builtins.str]:
        """
        Will include customer specific (preview) instances when enabled otherwise they will be excluded. Supported values: `enabled`, `disabled` or ``.
        """
        return pulumi.get(self, "customer_specific")

    @_builtins.property
    @pulumi.getter(name="dedicatedNodeAffinities")
    def dedicated_node_affinities(self) -> Optional[Sequence['outputs.NodeTemplateConstraintsDedicatedNodeAffinity']]:
        """
        Dedicated node affinity - creates preference for instances to be created on sole tenancy or dedicated nodes. This
         feature is only available for GCP clusters and sole tenancy nodes with local
         SSDs or GPUs are not supported. If the sole tenancy or dedicated nodes don't have capacity for selected instance
         type, the Autoscaler will fall back to multi-tenant instance types available for this Node Template.
         Other instance constraints are applied when the Autoscaler picks available instance types that can be created on
         the sole tenancy or dedicated node (example: setting min CPU to 16).
        """
        return pulumi.get(self, "dedicated_node_affinities")

    @_builtins.property
    @pulumi.getter(name="enableSpotDiversity")
    def enable_spot_diversity(self) -> Optional[_builtins.bool]:
        """
        Enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        """
        return pulumi.get(self, "enable_spot_diversity")

    @_builtins.property
    @pulumi.getter(name="fallbackRestoreRateSeconds")
    def fallback_restore_rate_seconds(self) -> Optional[_builtins.int]:
        """
        Fallback restore rate in seconds: defines how much time should pass before spot fallback should be attempted to be restored to real spot.
        """
        return pulumi.get(self, "fallback_restore_rate_seconds")

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> Optional['outputs.NodeTemplateConstraintsGpu']:
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter(name="instanceFamilies")
    def instance_families(self) -> Optional['outputs.NodeTemplateConstraintsInstanceFamilies']:
        return pulumi.get(self, "instance_families")

    @_builtins.property
    @pulumi.getter(name="isGpuOnly")
    def is_gpu_only(self) -> Optional[_builtins.bool]:
        """
        GPU instance constraint - will only pick nodes with GPU if true
        """
        return pulumi.get(self, "is_gpu_only")

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[_builtins.int]:
        """
        Max CPU cores per node.
        """
        return pulumi.get(self, "max_cpu")

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[_builtins.int]:
        """
        Max Memory (Mib) per node.
        """
        return pulumi.get(self, "max_memory")

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[_builtins.int]:
        """
        Min CPU cores per node.
        """
        return pulumi.get(self, "min_cpu")

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[_builtins.int]:
        """
        Min Memory (Mib) per node.
        """
        return pulumi.get(self, "min_memory")

    @_builtins.property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[_builtins.bool]:
        """
        Should include on-demand instances in the considered pool.
        """
        return pulumi.get(self, "on_demand")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of acceptable instance Operating Systems, the default is linux. Allowed values: linux, windows.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.NodeTemplateConstraintsResourceLimits']:
        return pulumi.get(self, "resource_limits")

    @_builtins.property
    @pulumi.getter
    def spot(self) -> Optional[_builtins.bool]:
        """
        Should include spot instances in the considered pool.
        """
        return pulumi.get(self, "spot")

    @_builtins.property
    @pulumi.getter(name="spotDiversityPriceIncreaseLimitPercent")
    def spot_diversity_price_increase_limit_percent(self) -> Optional[_builtins.int]:
        """
        Allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        """
        return pulumi.get(self, "spot_diversity_price_increase_limit_percent")

    @_builtins.property
    @pulumi.getter(name="spotInterruptionPredictionsEnabled")
    def spot_interruption_predictions_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable/disable spot interruption predictions.
        """
        return pulumi.get(self, "spot_interruption_predictions_enabled")

    @_builtins.property
    @pulumi.getter(name="spotInterruptionPredictionsType")
    def spot_interruption_predictions_type(self) -> Optional[_builtins.str]:
        """
        Spot interruption predictions type. Can be either "aws-rebalance-recommendations" or "interruption-predictions".
        """
        return pulumi.get(self, "spot_interruption_predictions_type")

    @_builtins.property
    @pulumi.getter(name="spotReliabilityEnabled")
    def spot_reliability_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable/disable spot reliability. When enabled, autoscaler will create instances with highest reliability score within price increase threshold.
        """
        return pulumi.get(self, "spot_reliability_enabled")

    @_builtins.property
    @pulumi.getter(name="spotReliabilityPriceIncreaseLimitPercent")
    def spot_reliability_price_increase_limit_percent(self) -> Optional[_builtins.int]:
        """
        Allowed node price increase when using spot reliability on ordering the instance types . E.g. if the value is 10%, then the overall price of instance types can be 10% higher than the price of the optimal configuration.
        """
        return pulumi.get(self, "spot_reliability_price_increase_limit_percent")

    @_builtins.property
    @pulumi.getter(name="storageOptimized")
    def storage_optimized(self) -> Optional[_builtins.bool]:
        """
        Storage optimized instance constraint (deprecated).
        """
        return pulumi.get(self, "storage_optimized")

    @_builtins.property
    @pulumi.getter(name="storageOptimizedState")
    def storage_optimized_state(self) -> Optional[_builtins.str]:
        """
        Storage optimized instance constraint - will only pick storage optimized nodes if enabled and won't pick if disabled. Empty value will have no effect. Supported values: `enabled`, `disabled` or empty string.
        """
        return pulumi.get(self, "storage_optimized_state")

    @_builtins.property
    @pulumi.getter(name="useSpotFallbacks")
    def use_spot_fallbacks(self) -> Optional[_builtins.bool]:
        """
        Spot instance fallback constraint - when true, on-demand instances will be created, when spots are unavailable.
        """
        return pulumi.get(self, "use_spot_fallbacks")


@pulumi.output_type
class NodeTemplateConstraintsCustomPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceFamilies":
            suggest = "instance_families"
        elif key == "onDemand":
            suggest = "on_demand"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateConstraintsCustomPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateConstraintsCustomPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateConstraintsCustomPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_families: Optional[Sequence[_builtins.str]] = None,
                 on_demand: Optional[_builtins.bool] = None,
                 spot: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] instance_families: Instance families to prioritize in this tier.
        :param _builtins.bool on_demand: If true, this tier will apply to on-demand instances.
        :param _builtins.bool spot: If true, this tier will apply to spot instances.
        """
        if instance_families is not None:
            pulumi.set(__self__, "instance_families", instance_families)
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if spot is not None:
            pulumi.set(__self__, "spot", spot)

    @_builtins.property
    @pulumi.getter(name="instanceFamilies")
    def instance_families(self) -> Optional[Sequence[_builtins.str]]:
        """
        Instance families to prioritize in this tier.
        """
        return pulumi.get(self, "instance_families")

    @_builtins.property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[_builtins.bool]:
        """
        If true, this tier will apply to on-demand instances.
        """
        return pulumi.get(self, "on_demand")

    @_builtins.property
    @pulumi.getter
    def spot(self) -> Optional[_builtins.bool]:
        """
        If true, this tier will apply to spot instances.
        """
        return pulumi.get(self, "spot")


@pulumi.output_type
class NodeTemplateConstraintsDedicatedNodeAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azName":
            suggest = "az_name"
        elif key == "instanceTypes":
            suggest = "instance_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateConstraintsDedicatedNodeAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateConstraintsDedicatedNodeAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateConstraintsDedicatedNodeAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 az_name: _builtins.str,
                 instance_types: Sequence[_builtins.str],
                 name: _builtins.str,
                 affinities: Optional[Sequence['outputs.NodeTemplateConstraintsDedicatedNodeAffinityAffinity']] = None):
        """
        :param _builtins.str az_name: Availability zone name.
        :param Sequence[_builtins.str] instance_types: Instance/node types in this node group.
        :param _builtins.str name: Name of node group.
        """
        pulumi.set(__self__, "az_name", az_name)
        pulumi.set(__self__, "instance_types", instance_types)
        pulumi.set(__self__, "name", name)
        if affinities is not None:
            pulumi.set(__self__, "affinities", affinities)

    @_builtins.property
    @pulumi.getter(name="azName")
    def az_name(self) -> _builtins.str:
        """
        Availability zone name.
        """
        return pulumi.get(self, "az_name")

    @_builtins.property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Sequence[_builtins.str]:
        """
        Instance/node types in this node group.
        """
        return pulumi.get(self, "instance_types")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of node group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def affinities(self) -> Optional[Sequence['outputs.NodeTemplateConstraintsDedicatedNodeAffinityAffinity']]:
        return pulumi.get(self, "affinities")


@pulumi.output_type
class NodeTemplateConstraintsDedicatedNodeAffinityAffinity(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Key of the node affinity selector.
        :param _builtins.str operator: Operator of the node affinity selector. Allowed values: In, NotIn, Exists, DoesNotExist, Gt, Lt.
        :param Sequence[_builtins.str] values: Values of the node affinity selector.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the node affinity selector.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operator of the node affinity selector. Allowed values: In, NotIn, Exists, DoesNotExist, Gt, Lt.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Values of the node affinity selector.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NodeTemplateConstraintsGpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeNames":
            suggest = "exclude_names"
        elif key == "includeNames":
            suggest = "include_names"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "minCount":
            suggest = "min_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateConstraintsGpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateConstraintsGpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateConstraintsGpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_names: Optional[Sequence[_builtins.str]] = None,
                 include_names: Optional[Sequence[_builtins.str]] = None,
                 manufacturers: Optional[Sequence[_builtins.str]] = None,
                 max_count: Optional[_builtins.int] = None,
                 min_count: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] exclude_names: Names of the GPUs to exclude.
        :param Sequence[_builtins.str] include_names: Instance families to include when filtering (excludes all other families).
        :param Sequence[_builtins.str] manufacturers: Manufacturers of the gpus to select - NVIDIA, AMD.
        :param _builtins.int max_count: Max GPU count for the instance type to have.
        :param _builtins.int min_count: Min GPU count for the instance type to have.
        """
        if exclude_names is not None:
            pulumi.set(__self__, "exclude_names", exclude_names)
        if include_names is not None:
            pulumi.set(__self__, "include_names", include_names)
        if manufacturers is not None:
            pulumi.set(__self__, "manufacturers", manufacturers)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)

    @_builtins.property
    @pulumi.getter(name="excludeNames")
    def exclude_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of the GPUs to exclude.
        """
        return pulumi.get(self, "exclude_names")

    @_builtins.property
    @pulumi.getter(name="includeNames")
    def include_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Instance families to include when filtering (excludes all other families).
        """
        return pulumi.get(self, "include_names")

    @_builtins.property
    @pulumi.getter
    def manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Manufacturers of the gpus to select - NVIDIA, AMD.
        """
        return pulumi.get(self, "manufacturers")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Max GPU count for the instance type to have.
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[_builtins.int]:
        """
        Min GPU count for the instance type to have.
        """
        return pulumi.get(self, "min_count")


@pulumi.output_type
class NodeTemplateConstraintsInstanceFamilies(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: Instance families to exclude when filtering (includes all other families).
        :param Sequence[_builtins.str] includes: Instance families to include when filtering (excludes all other families).
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Instance families to exclude when filtering (includes all other families).
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Instance families to include when filtering (excludes all other families).
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class NodeTemplateConstraintsResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimitEnabled":
            suggest = "cpu_limit_enabled"
        elif key == "cpuLimitMaxCores":
            suggest = "cpu_limit_max_cores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateConstraintsResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateConstraintsResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateConstraintsResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit_enabled: Optional[_builtins.bool] = None,
                 cpu_limit_max_cores: Optional[_builtins.int] = None):
        """
        :param _builtins.bool cpu_limit_enabled: Controls CPU limit enforcement for the node template.
        :param _builtins.int cpu_limit_max_cores: Specifies the maximum number of CPU cores that the nodes provisioned from this template can collectively have.
        """
        if cpu_limit_enabled is not None:
            pulumi.set(__self__, "cpu_limit_enabled", cpu_limit_enabled)
        if cpu_limit_max_cores is not None:
            pulumi.set(__self__, "cpu_limit_max_cores", cpu_limit_max_cores)

    @_builtins.property
    @pulumi.getter(name="cpuLimitEnabled")
    def cpu_limit_enabled(self) -> Optional[_builtins.bool]:
        """
        Controls CPU limit enforcement for the node template.
        """
        return pulumi.get(self, "cpu_limit_enabled")

    @_builtins.property
    @pulumi.getter(name="cpuLimitMaxCores")
    def cpu_limit_max_cores(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of CPU cores that the nodes provisioned from this template can collectively have.
        """
        return pulumi.get(self, "cpu_limit_max_cores")


@pulumi.output_type
class NodeTemplateCustomTaint(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Key of a taint to be added to nodes created from this template.
        :param _builtins.str effect: Effect of a taint to be added to nodes created from this template, the default is NoSchedule. Allowed values: NoSchedule, NoExecute.
        :param _builtins.str value: Value of a taint to be added to nodes created from this template.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of a taint to be added to nodes created from this template.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Effect of a taint to be added to nodes created from this template, the default is NoSchedule. Allowed values: NoSchedule, NoExecute.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of a taint to be added to nodes created from this template.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodeTemplateGpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSharedClientsPerGpu":
            suggest = "default_shared_clients_per_gpu"
        elif key == "enableTimeSharing":
            suggest = "enable_time_sharing"
        elif key == "sharingConfigurations":
            suggest = "sharing_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateGpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateGpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateGpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_shared_clients_per_gpu: Optional[_builtins.int] = None,
                 enable_time_sharing: Optional[_builtins.bool] = None,
                 sharing_configurations: Optional[Sequence['outputs.NodeTemplateGpuSharingConfiguration']] = None):
        """
        :param _builtins.int default_shared_clients_per_gpu: Defines default number of shared clients per GPU.
        :param _builtins.bool enable_time_sharing: Enable/disable GPU time-sharing.
        :param Sequence['NodeTemplateGpuSharingConfigurationArgs'] sharing_configurations: Defines GPU sharing configurations for GPU devices.
        """
        if default_shared_clients_per_gpu is not None:
            pulumi.set(__self__, "default_shared_clients_per_gpu", default_shared_clients_per_gpu)
        if enable_time_sharing is not None:
            pulumi.set(__self__, "enable_time_sharing", enable_time_sharing)
        if sharing_configurations is not None:
            pulumi.set(__self__, "sharing_configurations", sharing_configurations)

    @_builtins.property
    @pulumi.getter(name="defaultSharedClientsPerGpu")
    def default_shared_clients_per_gpu(self) -> Optional[_builtins.int]:
        """
        Defines default number of shared clients per GPU.
        """
        return pulumi.get(self, "default_shared_clients_per_gpu")

    @_builtins.property
    @pulumi.getter(name="enableTimeSharing")
    def enable_time_sharing(self) -> Optional[_builtins.bool]:
        """
        Enable/disable GPU time-sharing.
        """
        return pulumi.get(self, "enable_time_sharing")

    @_builtins.property
    @pulumi.getter(name="sharingConfigurations")
    def sharing_configurations(self) -> Optional[Sequence['outputs.NodeTemplateGpuSharingConfiguration']]:
        """
        Defines GPU sharing configurations for GPU devices.
        """
        return pulumi.get(self, "sharing_configurations")


@pulumi.output_type
class NodeTemplateGpuSharingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuName":
            suggest = "gpu_name"
        elif key == "sharedClientsPerGpu":
            suggest = "shared_clients_per_gpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateGpuSharingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateGpuSharingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateGpuSharingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gpu_name: _builtins.str,
                 shared_clients_per_gpu: _builtins.int):
        """
        :param _builtins.str gpu_name: GPU name.
        :param _builtins.int shared_clients_per_gpu: Defines number of shared clients for specific GPU device.
        """
        pulumi.set(__self__, "gpu_name", gpu_name)
        pulumi.set(__self__, "shared_clients_per_gpu", shared_clients_per_gpu)

    @_builtins.property
    @pulumi.getter(name="gpuName")
    def gpu_name(self) -> _builtins.str:
        """
        GPU name.
        """
        return pulumi.get(self, "gpu_name")

    @_builtins.property
    @pulumi.getter(name="sharedClientsPerGpu")
    def shared_clients_per_gpu(self) -> _builtins.int:
        """
        Defines number of shared clients for specific GPU device.
        """
        return pulumi.get(self, "shared_clients_per_gpu")


