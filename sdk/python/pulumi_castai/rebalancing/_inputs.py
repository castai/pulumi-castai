# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GetHibernationScheduleDataSourceClusterAssignmentArgs',
    'GetHibernationScheduleDataSourceClusterAssignmentArgsDict',
    'GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgs',
    'GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgsDict',
    'HibernationScheduleClusterAssignmentsArgs',
    'HibernationScheduleClusterAssignmentsArgsDict',
    'HibernationScheduleClusterAssignmentsAssignmentArgs',
    'HibernationScheduleClusterAssignmentsAssignmentArgsDict',
    'HibernationSchedulePauseConfigArgs',
    'HibernationSchedulePauseConfigArgsDict',
    'HibernationSchedulePauseConfigScheduleArgs',
    'HibernationSchedulePauseConfigScheduleArgsDict',
    'HibernationScheduleResumeConfigArgs',
    'HibernationScheduleResumeConfigArgsDict',
    'HibernationScheduleResumeConfigJobConfigArgs',
    'HibernationScheduleResumeConfigJobConfigArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgsDict',
    'HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgs',
    'HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgsDict',
    'HibernationScheduleResumeConfigScheduleArgs',
    'HibernationScheduleResumeConfigScheduleArgsDict',
    'RebalancingScheduleLaunchConfigurationArgs',
    'RebalancingScheduleLaunchConfigurationArgsDict',
    'RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgs',
    'RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgsDict',
    'RebalancingScheduleLaunchConfigurationExecutionConditionsArgs',
    'RebalancingScheduleLaunchConfigurationExecutionConditionsArgsDict',
    'RebalancingScheduleScheduleArgs',
    'RebalancingScheduleScheduleArgsDict',
    'RebalancingScheduleTriggerConditionsArgs',
    'RebalancingScheduleTriggerConditionsArgsDict',
]

MYPY = False

if not MYPY:
    class GetHibernationScheduleDataSourceClusterAssignmentArgsDict(TypedDict):
        assignments: NotRequired[Sequence['GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgsDict']]
elif False:
    GetHibernationScheduleDataSourceClusterAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHibernationScheduleDataSourceClusterAssignmentArgs:
    def __init__(__self__, *,
                 assignments: Optional[Sequence['GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgs']] = None):
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgs']]:
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[Sequence['GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgs']]):
        pulumi.set(self, "assignments", value)


if not MYPY:
    class GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgsDict(TypedDict):
        cluster_id: _builtins.str
        """
        ID of the cluster.
        """
elif False:
    GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHibernationScheduleDataSourceClusterAssignmentAssignmentArgs:
    def __init__(__self__, *,
                 cluster_id: _builtins.str):
        """
        :param _builtins.str cluster_id: ID of the cluster.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: _builtins.str):
        pulumi.set(self, "cluster_id", value)


if not MYPY:
    class HibernationScheduleClusterAssignmentsArgsDict(TypedDict):
        assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleClusterAssignmentsAssignmentArgsDict']]]]
elif False:
    HibernationScheduleClusterAssignmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleClusterAssignmentsArgs:
    def __init__(__self__, *,
                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleClusterAssignmentsAssignmentArgs']]]] = None):
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleClusterAssignmentsAssignmentArgs']]]]:
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleClusterAssignmentsAssignmentArgs']]]]):
        pulumi.set(self, "assignments", value)


if not MYPY:
    class HibernationScheduleClusterAssignmentsAssignmentArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        ID of the cluster.
        """
elif False:
    HibernationScheduleClusterAssignmentsAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleClusterAssignmentsAssignmentArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cluster_id: ID of the cluster.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)


if not MYPY:
    class HibernationSchedulePauseConfigArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enables or disables the pause configuration.
        """
        schedule: pulumi.Input['HibernationSchedulePauseConfigScheduleArgsDict']
elif False:
    HibernationSchedulePauseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationSchedulePauseConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 schedule: pulumi.Input['HibernationSchedulePauseConfigScheduleArgs']):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables or disables the pause configuration.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables or disables the pause configuration.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['HibernationSchedulePauseConfigScheduleArgs']:
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['HibernationSchedulePauseConfigScheduleArgs']):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class HibernationSchedulePauseConfigScheduleArgsDict(TypedDict):
        cron_expression: pulumi.Input[_builtins.str]
        """
        Cron expression defining when the schedule should trigger.

          The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.

          Example:
          ```plaintext
          CRON_TZ=America/New_York 0 12 * * ?
        ```
          In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.

          To retrieve a list of available timezone values, you can use the following API endpoint:

          GET https://api.cast.ai/v1/time-zones

          When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
elif False:
    HibernationSchedulePauseConfigScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationSchedulePauseConfigScheduleArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cron_expression: Cron expression defining when the schedule should trigger.
               
                 The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.
               
                 Example:
                 ```plaintext
                 CRON_TZ=America/New_York 0 12 * * ?
               ```
                 In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.
               
                 To retrieve a list of available timezone values, you can use the following API endpoint:
               
                 GET https://api.cast.ai/v1/time-zones
               
                 When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[_builtins.str]:
        """
        Cron expression defining when the schedule should trigger.

          The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.

          Example:
          ```plaintext
          CRON_TZ=America/New_York 0 12 * * ?
        ```
          In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.

          To retrieve a list of available timezone values, you can use the following API endpoint:

          GET https://api.cast.ai/v1/time-zones

          When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron_expression", value)


if not MYPY:
    class HibernationScheduleResumeConfigArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enables or disables the pause configuration.
        """
        job_config: pulumi.Input['HibernationScheduleResumeConfigJobConfigArgsDict']
        schedule: pulumi.Input['HibernationScheduleResumeConfigScheduleArgsDict']
elif False:
    HibernationScheduleResumeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 job_config: pulumi.Input['HibernationScheduleResumeConfigJobConfigArgs'],
                 schedule: pulumi.Input['HibernationScheduleResumeConfigScheduleArgs']):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables or disables the pause configuration.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "job_config", job_config)
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables or disables the pause configuration.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="jobConfig")
    def job_config(self) -> pulumi.Input['HibernationScheduleResumeConfigJobConfigArgs']:
        return pulumi.get(self, "job_config")

    @job_config.setter
    def job_config(self, value: pulumi.Input['HibernationScheduleResumeConfigJobConfigArgs']):
        pulumi.set(self, "job_config", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['HibernationScheduleResumeConfigScheduleArgs']:
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['HibernationScheduleResumeConfigScheduleArgs']):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigArgsDict(TypedDict):
        node_config: pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigArgsDict']
elif False:
    HibernationScheduleResumeConfigJobConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigArgs:
    def __init__(__self__, *,
                 node_config: pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigArgs']):
        pulumi.set(__self__, "node_config", node_config)

    @_builtins.property
    @pulumi.getter(name="nodeConfig")
    def node_config(self) -> pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigArgs']:
        return pulumi.get(self, "node_config")

    @node_config.setter
    def node_config(self, value: pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigArgs']):
        pulumi.set(self, "node_config", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        """
        Instance type.
        """
        config_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID reference of Node Configuration to be used for node creation. Supersedes 'config_name' parameter.
        """
        config_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name reference of Node Configuration to be used for node creation. Superseded if 'config_id' parameter is provided.
        """
        gpu_config: NotRequired[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgsDict']]
        kubernetes_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom labels to be added to the node.
        """
        kubernetes_taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgsDict']]]]
        """
        Custom taints to be added to the node created from this configuration.
        """
        node_affinities: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgsDict']]]]
        """
        Custom taints to be added to the node created from this configuration.
        """
        spot_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgsDict']]]]
        """
        Custom taints to be added to the node created from this configuration.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node subnet ID.
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgsDict']]]]
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Zone of the node.
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 config_id: Optional[pulumi.Input[_builtins.str]] = None,
                 config_name: Optional[pulumi.Input[_builtins.str]] = None,
                 gpu_config: Optional[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgs']] = None,
                 kubernetes_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 kubernetes_taints: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgs']]]] = None,
                 node_affinities: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgs']]]] = None,
                 spot_configs: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgs']]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgs']]]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_type: Instance type.
        :param pulumi.Input[_builtins.str] config_id: ID reference of Node Configuration to be used for node creation. Supersedes 'config_name' parameter.
        :param pulumi.Input[_builtins.str] config_name: Name reference of Node Configuration to be used for node creation. Superseded if 'config_id' parameter is provided.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] kubernetes_labels: Custom labels to be added to the node.
        :param pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgs']]] kubernetes_taints: Custom taints to be added to the node created from this configuration.
        :param pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgs']]] node_affinities: Custom taints to be added to the node created from this configuration.
        :param pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgs']]] spot_configs: Custom taints to be added to the node created from this configuration.
        :param pulumi.Input[_builtins.str] subnet_id: Node subnet ID.
        :param pulumi.Input[_builtins.str] zone: Zone of the node.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if config_name is not None:
            pulumi.set(__self__, "config_name", config_name)
        if gpu_config is not None:
            pulumi.set(__self__, "gpu_config", gpu_config)
        if kubernetes_labels is not None:
            pulumi.set(__self__, "kubernetes_labels", kubernetes_labels)
        if kubernetes_taints is not None:
            pulumi.set(__self__, "kubernetes_taints", kubernetes_taints)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if spot_configs is not None:
            pulumi.set(__self__, "spot_configs", spot_configs)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID reference of Node Configuration to be used for node creation. Supersedes 'config_name' parameter.
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_id", value)

    @_builtins.property
    @pulumi.getter(name="configName")
    def config_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name reference of Node Configuration to be used for node creation. Superseded if 'config_id' parameter is provided.
        """
        return pulumi.get(self, "config_name")

    @config_name.setter
    def config_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_name", value)

    @_builtins.property
    @pulumi.getter(name="gpuConfig")
    def gpu_config(self) -> Optional[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgs']]:
        return pulumi.get(self, "gpu_config")

    @gpu_config.setter
    def gpu_config(self, value: Optional[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgs']]):
        pulumi.set(self, "gpu_config", value)

    @_builtins.property
    @pulumi.getter(name="kubernetesLabels")
    def kubernetes_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom labels to be added to the node.
        """
        return pulumi.get(self, "kubernetes_labels")

    @kubernetes_labels.setter
    def kubernetes_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "kubernetes_labels", value)

    @_builtins.property
    @pulumi.getter(name="kubernetesTaints")
    def kubernetes_taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgs']]]]:
        """
        Custom taints to be added to the node created from this configuration.
        """
        return pulumi.get(self, "kubernetes_taints")

    @kubernetes_taints.setter
    def kubernetes_taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgs']]]]):
        pulumi.set(self, "kubernetes_taints", value)

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgs']]]]:
        """
        Custom taints to be added to the node created from this configuration.
        """
        return pulumi.get(self, "node_affinities")

    @node_affinities.setter
    def node_affinities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgs']]]]):
        pulumi.set(self, "node_affinities", value)

    @_builtins.property
    @pulumi.getter(name="spotConfigs")
    def spot_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgs']]]]:
        """
        Custom taints to be added to the node created from this configuration.
        """
        return pulumi.get(self, "spot_configs")

    @spot_configs.setter
    def spot_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgs']]]]):
        pulumi.set(self, "spot_configs", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgs']]]]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Zone of the node.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Number of GPUs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        GPU type.
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigGpuConfigArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Number of GPUs.
        :param pulumi.Input[_builtins.str] type: GPU type.
        """
        pulumi.set(__self__, "count", count)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GPU type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key of a taint to be added to nodes created from this template.
        """
        effect: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effect of a taint to be added to nodes created from this template, the default is NoSchedule. Allowed values: NoSchedule, NoExecute.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of a taint to be added to nodes created from this template.
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigKubernetesTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key of a taint to be added to nodes created from this template.
        :param pulumi.Input[_builtins.str] effect: Effect of a taint to be added to nodes created from this template, the default is NoSchedule. Allowed values: NoSchedule, NoExecute.
        :param pulumi.Input[_builtins.str] value: Value of a taint to be added to nodes created from this template.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of a taint to be added to nodes created from this template.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effect of a taint to be added to nodes created from this template, the default is NoSchedule. Allowed values: NoSchedule, NoExecute.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of a taint to be added to nodes created from this template.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgsDict(TypedDict):
        dedicated_group: pulumi.Input[_builtins.str]
        """
        Key of a taint to be added to nodes created from this template.
        """
        affinities: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgsDict']]]]
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityArgs:
    def __init__(__self__, *,
                 dedicated_group: pulumi.Input[_builtins.str],
                 affinities: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] dedicated_group: Key of a taint to be added to nodes created from this template.
        """
        pulumi.set(__self__, "dedicated_group", dedicated_group)
        if affinities is not None:
            pulumi.set(__self__, "affinities", affinities)

    @_builtins.property
    @pulumi.getter(name="dedicatedGroup")
    def dedicated_group(self) -> pulumi.Input[_builtins.str]:
        """
        Key of a taint to be added to nodes created from this template.
        """
        return pulumi.get(self, "dedicated_group")

    @dedicated_group.setter
    def dedicated_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dedicated_group", value)

    @_builtins.property
    @pulumi.getter
    def affinities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgs']]]]:
        return pulumi.get(self, "affinities")

    @affinities.setter
    def affinities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgs']]]]):
        pulumi.set(self, "affinities", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key of the node affinity selector.
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator of the node affinity selector. Allowed values: DOES_NOT_EXIST, EXISTS, GT, IN, LT, NOT_IN.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Values of the node affinity selector.
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigNodeAffinityAffinityArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: Key of the node affinity selector.
        :param pulumi.Input[_builtins.str] operator: Operator of the node affinity selector. Allowed values: DOES_NOT_EXIST, EXISTS, GT, IN, LT, NOT_IN.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Values of the node affinity selector.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of the node affinity selector.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator of the node affinity selector. Allowed values: DOES_NOT_EXIST, EXISTS, GT, IN, LT, NOT_IN.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Values of the node affinity selector.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgsDict(TypedDict):
        price_hourly: NotRequired[pulumi.Input[_builtins.str]]
        """
        Spot instance price. Applicable only for AWS nodes.
        """
        spot: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether node should be created as spot instance.
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigSpotConfigArgs:
    def __init__(__self__, *,
                 price_hourly: Optional[pulumi.Input[_builtins.str]] = None,
                 spot: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] price_hourly: Spot instance price. Applicable only for AWS nodes.
        :param pulumi.Input[_builtins.bool] spot: Whether node should be created as spot instance.
        """
        if price_hourly is not None:
            pulumi.set(__self__, "price_hourly", price_hourly)
        if spot is not None:
            pulumi.set(__self__, "spot", spot)

    @_builtins.property
    @pulumi.getter(name="priceHourly")
    def price_hourly(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Spot instance price. Applicable only for AWS nodes.
        """
        return pulumi.get(self, "price_hourly")

    @price_hourly.setter
    def price_hourly(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "price_hourly", value)

    @_builtins.property
    @pulumi.getter
    def spot(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether node should be created as spot instance.
        """
        return pulumi.get(self, "spot")

    @spot.setter
    def spot(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "spot", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgsDict(TypedDict):
        raid_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgsDict']]]]
        size_gib: NotRequired[pulumi.Input[_builtins.int]]
        """
        Volume size in GiB.
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 raid_configs: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgs']]]] = None,
                 size_gib: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size_gib: Volume size in GiB.
        """
        if raid_configs is not None:
            pulumi.set(__self__, "raid_configs", raid_configs)
        if size_gib is not None:
            pulumi.set(__self__, "size_gib", size_gib)

    @_builtins.property
    @pulumi.getter(name="raidConfigs")
    def raid_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgs']]]]:
        return pulumi.get(self, "raid_configs")

    @raid_configs.setter
    def raid_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgs']]]]):
        pulumi.set(self, "raid_configs", value)

    @_builtins.property
    @pulumi.getter(name="sizeGib")
    def size_gib(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Volume size in GiB.
        """
        return pulumi.get(self, "size_gib")

    @size_gib.setter
    def size_gib(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size_gib", value)


if not MYPY:
    class HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgsDict(TypedDict):
        chunk_size_kb: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify the RAID0 chunk size in kilobytes, this parameter affects the read/write in the disk array and must be tailored for the type of data written by the workloads in the node. If not provided it will default to 64KB
        """
elif False:
    HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigJobConfigNodeConfigVolumeRaidConfigArgs:
    def __init__(__self__, *,
                 chunk_size_kb: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] chunk_size_kb: Specify the RAID0 chunk size in kilobytes, this parameter affects the read/write in the disk array and must be tailored for the type of data written by the workloads in the node. If not provided it will default to 64KB
        """
        if chunk_size_kb is not None:
            pulumi.set(__self__, "chunk_size_kb", chunk_size_kb)

    @_builtins.property
    @pulumi.getter(name="chunkSizeKb")
    def chunk_size_kb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify the RAID0 chunk size in kilobytes, this parameter affects the read/write in the disk array and must be tailored for the type of data written by the workloads in the node. If not provided it will default to 64KB
        """
        return pulumi.get(self, "chunk_size_kb")

    @chunk_size_kb.setter
    def chunk_size_kb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "chunk_size_kb", value)


if not MYPY:
    class HibernationScheduleResumeConfigScheduleArgsDict(TypedDict):
        cron_expression: pulumi.Input[_builtins.str]
        """
        Cron expression defining when the schedule should trigger.

          The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.

          Example:
          ```plaintext
          CRON_TZ=America/New_York 0 12 * * ?
        ```
          In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.

          To retrieve a list of available timezone values, you can use the following API endpoint:

          GET https://api.cast.ai/v1/time-zones

          When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
elif False:
    HibernationScheduleResumeConfigScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationScheduleResumeConfigScheduleArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cron_expression: Cron expression defining when the schedule should trigger.
               
                 The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.
               
                 Example:
                 ```plaintext
                 CRON_TZ=America/New_York 0 12 * * ?
               ```
                 In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.
               
                 To retrieve a list of available timezone values, you can use the following API endpoint:
               
                 GET https://api.cast.ai/v1/time-zones
               
                 When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[_builtins.str]:
        """
        Cron expression defining when the schedule should trigger.

          The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.

          Example:
          ```plaintext
          CRON_TZ=America/New_York 0 12 * * ?
        ```
          In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.

          To retrieve a list of available timezone values, you can use the following API endpoint:

          GET https://api.cast.ai/v1/time-zones

          When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron_expression", value)


if not MYPY:
    class RebalancingScheduleLaunchConfigurationArgsDict(TypedDict):
        aggressive_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled rebalancing will also consider problematic pods (pods without controller, job pods, pods with removal-disabled annotation) as not-problematic.
        """
        aggressive_mode_config: NotRequired[pulumi.Input['RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgsDict']]
        """
        Advanced configuration for aggressive rebalancing mode.
        """
        execution_conditions: NotRequired[pulumi.Input['RebalancingScheduleLaunchConfigurationExecutionConditionsArgsDict']]
        keep_drain_timeout_nodes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
        """
        node_ttl_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
        """
        num_targeted_nodes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of nodes that will be selected for rebalancing.
        """
        rebalancing_min_nodes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of nodes that should be kept in the cluster after rebalancing.
        """
        selector: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node selector in JSON format.
        """
        target_node_selection_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the algorithm used to select the target nodes for rebalancing.
        """
elif False:
    RebalancingScheduleLaunchConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RebalancingScheduleLaunchConfigurationArgs:
    def __init__(__self__, *,
                 aggressive_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 aggressive_mode_config: Optional[pulumi.Input['RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgs']] = None,
                 execution_conditions: Optional[pulumi.Input['RebalancingScheduleLaunchConfigurationExecutionConditionsArgs']] = None,
                 keep_drain_timeout_nodes: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_ttl_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 num_targeted_nodes: Optional[pulumi.Input[_builtins.int]] = None,
                 rebalancing_min_nodes: Optional[pulumi.Input[_builtins.int]] = None,
                 selector: Optional[pulumi.Input[_builtins.str]] = None,
                 target_node_selection_algorithm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] aggressive_mode: When enabled rebalancing will also consider problematic pods (pods without controller, job pods, pods with removal-disabled annotation) as not-problematic.
        :param pulumi.Input['RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgs'] aggressive_mode_config: Advanced configuration for aggressive rebalancing mode.
        :param pulumi.Input[_builtins.bool] keep_drain_timeout_nodes: Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
        :param pulumi.Input[_builtins.int] node_ttl_seconds: Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
        :param pulumi.Input[_builtins.int] num_targeted_nodes: Maximum number of nodes that will be selected for rebalancing.
        :param pulumi.Input[_builtins.int] rebalancing_min_nodes: Minimum number of nodes that should be kept in the cluster after rebalancing.
        :param pulumi.Input[_builtins.str] selector: Node selector in JSON format.
        :param pulumi.Input[_builtins.str] target_node_selection_algorithm: Defines the algorithm used to select the target nodes for rebalancing.
        """
        if aggressive_mode is not None:
            pulumi.set(__self__, "aggressive_mode", aggressive_mode)
        if aggressive_mode_config is not None:
            pulumi.set(__self__, "aggressive_mode_config", aggressive_mode_config)
        if execution_conditions is not None:
            pulumi.set(__self__, "execution_conditions", execution_conditions)
        if keep_drain_timeout_nodes is not None:
            pulumi.set(__self__, "keep_drain_timeout_nodes", keep_drain_timeout_nodes)
        if node_ttl_seconds is not None:
            pulumi.set(__self__, "node_ttl_seconds", node_ttl_seconds)
        if num_targeted_nodes is not None:
            pulumi.set(__self__, "num_targeted_nodes", num_targeted_nodes)
        if rebalancing_min_nodes is not None:
            pulumi.set(__self__, "rebalancing_min_nodes", rebalancing_min_nodes)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if target_node_selection_algorithm is not None:
            pulumi.set(__self__, "target_node_selection_algorithm", target_node_selection_algorithm)

    @_builtins.property
    @pulumi.getter(name="aggressiveMode")
    def aggressive_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled rebalancing will also consider problematic pods (pods without controller, job pods, pods with removal-disabled annotation) as not-problematic.
        """
        return pulumi.get(self, "aggressive_mode")

    @aggressive_mode.setter
    def aggressive_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "aggressive_mode", value)

    @_builtins.property
    @pulumi.getter(name="aggressiveModeConfig")
    def aggressive_mode_config(self) -> Optional[pulumi.Input['RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgs']]:
        """
        Advanced configuration for aggressive rebalancing mode.
        """
        return pulumi.get(self, "aggressive_mode_config")

    @aggressive_mode_config.setter
    def aggressive_mode_config(self, value: Optional[pulumi.Input['RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgs']]):
        pulumi.set(self, "aggressive_mode_config", value)

    @_builtins.property
    @pulumi.getter(name="executionConditions")
    def execution_conditions(self) -> Optional[pulumi.Input['RebalancingScheduleLaunchConfigurationExecutionConditionsArgs']]:
        return pulumi.get(self, "execution_conditions")

    @execution_conditions.setter
    def execution_conditions(self, value: Optional[pulumi.Input['RebalancingScheduleLaunchConfigurationExecutionConditionsArgs']]):
        pulumi.set(self, "execution_conditions", value)

    @_builtins.property
    @pulumi.getter(name="keepDrainTimeoutNodes")
    def keep_drain_timeout_nodes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
        """
        return pulumi.get(self, "keep_drain_timeout_nodes")

    @keep_drain_timeout_nodes.setter
    def keep_drain_timeout_nodes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keep_drain_timeout_nodes", value)

    @_builtins.property
    @pulumi.getter(name="nodeTtlSeconds")
    def node_ttl_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
        """
        return pulumi.get(self, "node_ttl_seconds")

    @node_ttl_seconds.setter
    def node_ttl_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_ttl_seconds", value)

    @_builtins.property
    @pulumi.getter(name="numTargetedNodes")
    def num_targeted_nodes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of nodes that will be selected for rebalancing.
        """
        return pulumi.get(self, "num_targeted_nodes")

    @num_targeted_nodes.setter
    def num_targeted_nodes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_targeted_nodes", value)

    @_builtins.property
    @pulumi.getter(name="rebalancingMinNodes")
    def rebalancing_min_nodes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of nodes that should be kept in the cluster after rebalancing.
        """
        return pulumi.get(self, "rebalancing_min_nodes")

    @rebalancing_min_nodes.setter
    def rebalancing_min_nodes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rebalancing_min_nodes", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node selector in JSON format.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter(name="targetNodeSelectionAlgorithm")
    def target_node_selection_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the algorithm used to select the target nodes for rebalancing.
        """
        return pulumi.get(self, "target_node_selection_algorithm")

    @target_node_selection_algorithm.setter
    def target_node_selection_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_node_selection_algorithm", value)


if not MYPY:
    class RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgsDict(TypedDict):
        ignore_local_persistent_volumes: pulumi.Input[_builtins.bool]
        """
        Rebalance workloads that use local-path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
        """
        ignore_problem_job_pods: pulumi.Input[_builtins.bool]
        """
        Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
        """
        ignore_problem_pods_without_controller: pulumi.Input[_builtins.bool]
        """
        Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
        """
        ignore_problem_removal_disabled_pods: pulumi.Input[_builtins.bool]
        """
        Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
        """
elif False:
    RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RebalancingScheduleLaunchConfigurationAggressiveModeConfigArgs:
    def __init__(__self__, *,
                 ignore_local_persistent_volumes: pulumi.Input[_builtins.bool],
                 ignore_problem_job_pods: pulumi.Input[_builtins.bool],
                 ignore_problem_pods_without_controller: pulumi.Input[_builtins.bool],
                 ignore_problem_removal_disabled_pods: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] ignore_local_persistent_volumes: Rebalance workloads that use local-path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
        :param pulumi.Input[_builtins.bool] ignore_problem_job_pods: Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
        :param pulumi.Input[_builtins.bool] ignore_problem_pods_without_controller: Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
        :param pulumi.Input[_builtins.bool] ignore_problem_removal_disabled_pods: Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
        """
        pulumi.set(__self__, "ignore_local_persistent_volumes", ignore_local_persistent_volumes)
        pulumi.set(__self__, "ignore_problem_job_pods", ignore_problem_job_pods)
        pulumi.set(__self__, "ignore_problem_pods_without_controller", ignore_problem_pods_without_controller)
        pulumi.set(__self__, "ignore_problem_removal_disabled_pods", ignore_problem_removal_disabled_pods)

    @_builtins.property
    @pulumi.getter(name="ignoreLocalPersistentVolumes")
    def ignore_local_persistent_volumes(self) -> pulumi.Input[_builtins.bool]:
        """
        Rebalance workloads that use local-path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
        """
        return pulumi.get(self, "ignore_local_persistent_volumes")

    @ignore_local_persistent_volumes.setter
    def ignore_local_persistent_volumes(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "ignore_local_persistent_volumes", value)

    @_builtins.property
    @pulumi.getter(name="ignoreProblemJobPods")
    def ignore_problem_job_pods(self) -> pulumi.Input[_builtins.bool]:
        """
        Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
        """
        return pulumi.get(self, "ignore_problem_job_pods")

    @ignore_problem_job_pods.setter
    def ignore_problem_job_pods(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "ignore_problem_job_pods", value)

    @_builtins.property
    @pulumi.getter(name="ignoreProblemPodsWithoutController")
    def ignore_problem_pods_without_controller(self) -> pulumi.Input[_builtins.bool]:
        """
        Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
        """
        return pulumi.get(self, "ignore_problem_pods_without_controller")

    @ignore_problem_pods_without_controller.setter
    def ignore_problem_pods_without_controller(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "ignore_problem_pods_without_controller", value)

    @_builtins.property
    @pulumi.getter(name="ignoreProblemRemovalDisabledPods")
    def ignore_problem_removal_disabled_pods(self) -> pulumi.Input[_builtins.bool]:
        """
        Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
        """
        return pulumi.get(self, "ignore_problem_removal_disabled_pods")

    @ignore_problem_removal_disabled_pods.setter
    def ignore_problem_removal_disabled_pods(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "ignore_problem_removal_disabled_pods", value)


if not MYPY:
    class RebalancingScheduleLaunchConfigurationExecutionConditionsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enables or disables the execution conditions.
        """
        achieved_savings_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
        """
elif False:
    RebalancingScheduleLaunchConfigurationExecutionConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RebalancingScheduleLaunchConfigurationExecutionConditionsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 achieved_savings_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables or disables the execution conditions.
        :param pulumi.Input[_builtins.int] achieved_savings_percentage: The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
        """
        pulumi.set(__self__, "enabled", enabled)
        if achieved_savings_percentage is not None:
            pulumi.set(__self__, "achieved_savings_percentage", achieved_savings_percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables or disables the execution conditions.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="achievedSavingsPercentage")
    def achieved_savings_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
        """
        return pulumi.get(self, "achieved_savings_percentage")

    @achieved_savings_percentage.setter
    def achieved_savings_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "achieved_savings_percentage", value)


if not MYPY:
    class RebalancingScheduleScheduleArgsDict(TypedDict):
        cron: pulumi.Input[_builtins.str]
        """
        Cron expression defining when the schedule should trigger.

          The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.

          Example:
          ```plaintext
          CRON_TZ=America/New_York 0 12 * * ?
        ```
          In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.

          To retrieve a list of available timezone values, you can use the following API endpoint:

          GET https://api.cast.ai/v1/time-zones

          When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
elif False:
    RebalancingScheduleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RebalancingScheduleScheduleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cron: Cron expression defining when the schedule should trigger.
               
                 The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.
               
                 Example:
                 ```plaintext
                 CRON_TZ=America/New_York 0 12 * * ?
               ```
                 In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.
               
                 To retrieve a list of available timezone values, you can use the following API endpoint:
               
                 GET https://api.cast.ai/v1/time-zones
               
                 When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
        pulumi.set(__self__, "cron", cron)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        """
        Cron expression defining when the schedule should trigger.

          The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.

          Example:
          ```plaintext
          CRON_TZ=America/New_York 0 12 * * ?
        ```
          In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.

          To retrieve a list of available timezone values, you can use the following API endpoint:

          GET https://api.cast.ai/v1/time-zones

          When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)


if not MYPY:
    class RebalancingScheduleTriggerConditionsArgsDict(TypedDict):
        savings_percentage: pulumi.Input[_builtins.float]
        """
        Defines the minimum percentage of savings expected.
        """
        ignore_savings: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
        """
elif False:
    RebalancingScheduleTriggerConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RebalancingScheduleTriggerConditionsArgs:
    def __init__(__self__, *,
                 savings_percentage: pulumi.Input[_builtins.float],
                 ignore_savings: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.float] savings_percentage: Defines the minimum percentage of savings expected.
        :param pulumi.Input[_builtins.bool] ignore_savings: If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
        """
        pulumi.set(__self__, "savings_percentage", savings_percentage)
        if ignore_savings is not None:
            pulumi.set(__self__, "ignore_savings", ignore_savings)

    @_builtins.property
    @pulumi.getter(name="savingsPercentage")
    def savings_percentage(self) -> pulumi.Input[_builtins.float]:
        """
        Defines the minimum percentage of savings expected.
        """
        return pulumi.get(self, "savings_percentage")

    @savings_percentage.setter
    def savings_percentage(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "savings_percentage", value)

    @_builtins.property
    @pulumi.getter(name="ignoreSavings")
    def ignore_savings(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
        """
        return pulumi.get(self, "ignore_savings")

    @ignore_savings.setter
    def ignore_savings(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_savings", value)


