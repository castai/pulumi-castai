# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AutoscalerAutoscalerSettings',
    'AutoscalerAutoscalerSettingsClusterLimits',
    'AutoscalerAutoscalerSettingsClusterLimitsCpu',
    'AutoscalerAutoscalerSettingsNodeDownscaler',
    'AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes',
    'AutoscalerAutoscalerSettingsNodeDownscalerEvictor',
    'AutoscalerAutoscalerSettingsSpotInstances',
    'AutoscalerAutoscalerSettingsSpotInstancesSpotBackups',
    'AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions',
    'AutoscalerAutoscalerSettingsUnschedulablePods',
    'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom',
    'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot',
    'AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints',
    'AutoscalerAutoscalerSettingsUnschedulablePodsPodPinner',
    'EvictorAdvancedConfigEvictorAdvancedConfig',
    'EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector',
    'EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpression',
    'EvictorAdvancedConfigEvictorAdvancedConfigPodSelector',
    'EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpression',
]

@pulumi.output_type
class AutoscalerAutoscalerSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterLimits":
            suggest = "cluster_limits"
        elif key == "isScopedMode":
            suggest = "is_scoped_mode"
        elif key == "nodeDownscaler":
            suggest = "node_downscaler"
        elif key == "nodeTemplatesPartialMatchingEnabled":
            suggest = "node_templates_partial_matching_enabled"
        elif key == "spotInstances":
            suggest = "spot_instances"
        elif key == "unschedulablePods":
            suggest = "unschedulable_pods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_limits: Optional['outputs.AutoscalerAutoscalerSettingsClusterLimits'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 is_scoped_mode: Optional[_builtins.bool] = None,
                 node_downscaler: Optional['outputs.AutoscalerAutoscalerSettingsNodeDownscaler'] = None,
                 node_templates_partial_matching_enabled: Optional[_builtins.bool] = None,
                 spot_instances: Optional['outputs.AutoscalerAutoscalerSettingsSpotInstances'] = None,
                 unschedulable_pods: Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePods'] = None):
        """
        :param 'AutoscalerAutoscalerSettingsClusterLimitsArgs' cluster_limits: defines minimum and maximum amount of CPU the cluster can have.
        :param _builtins.bool enabled: enable/disable autoscaler policies
        :param _builtins.bool is_scoped_mode: run autoscaler in scoped mode. Only marked pods and nodes will be considered.
        :param 'AutoscalerAutoscalerSettingsNodeDownscalerArgs' node_downscaler: node downscaler defines policies for removing nodes based on the configured conditions.
        :param _builtins.bool node_templates_partial_matching_enabled: marks whether partial matching should be used when deciding which custom node template to select.
        :param 'AutoscalerAutoscalerSettingsSpotInstancesArgs' spot_instances: policy defining whether autoscaler can use spot instances for provisioning additional workloads.
        :param 'AutoscalerAutoscalerSettingsUnschedulablePodsArgs' unschedulable_pods: policy defining autoscaler's behavior when unschedulable pods were detected.
        """
        if cluster_limits is not None:
            pulumi.set(__self__, "cluster_limits", cluster_limits)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if is_scoped_mode is not None:
            pulumi.set(__self__, "is_scoped_mode", is_scoped_mode)
        if node_downscaler is not None:
            pulumi.set(__self__, "node_downscaler", node_downscaler)
        if node_templates_partial_matching_enabled is not None:
            pulumi.set(__self__, "node_templates_partial_matching_enabled", node_templates_partial_matching_enabled)
        if spot_instances is not None:
            pulumi.set(__self__, "spot_instances", spot_instances)
        if unschedulable_pods is not None:
            pulumi.set(__self__, "unschedulable_pods", unschedulable_pods)

    @_builtins.property
    @pulumi.getter(name="clusterLimits")
    def cluster_limits(self) -> Optional['outputs.AutoscalerAutoscalerSettingsClusterLimits']:
        """
        defines minimum and maximum amount of CPU the cluster can have.
        """
        return pulumi.get(self, "cluster_limits")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable autoscaler policies
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="isScopedMode")
    def is_scoped_mode(self) -> Optional[_builtins.bool]:
        """
        run autoscaler in scoped mode. Only marked pods and nodes will be considered.
        """
        return pulumi.get(self, "is_scoped_mode")

    @_builtins.property
    @pulumi.getter(name="nodeDownscaler")
    def node_downscaler(self) -> Optional['outputs.AutoscalerAutoscalerSettingsNodeDownscaler']:
        """
        node downscaler defines policies for removing nodes based on the configured conditions.
        """
        return pulumi.get(self, "node_downscaler")

    @_builtins.property
    @pulumi.getter(name="nodeTemplatesPartialMatchingEnabled")
    def node_templates_partial_matching_enabled(self) -> Optional[_builtins.bool]:
        """
        marks whether partial matching should be used when deciding which custom node template to select.
        """
        return pulumi.get(self, "node_templates_partial_matching_enabled")

    @_builtins.property
    @pulumi.getter(name="spotInstances")
    @_utilities.deprecated("""`spot_instances` is deprecated. Configure spot instance settings using the `constraints` field in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_instances(self) -> Optional['outputs.AutoscalerAutoscalerSettingsSpotInstances']:
        """
        policy defining whether autoscaler can use spot instances for provisioning additional workloads.
        """
        return pulumi.get(self, "spot_instances")

    @_builtins.property
    @pulumi.getter(name="unschedulablePods")
    def unschedulable_pods(self) -> Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePods']:
        """
        policy defining autoscaler's behavior when unschedulable pods were detected.
        """
        return pulumi.get(self, "unschedulable_pods")


@pulumi.output_type
class AutoscalerAutoscalerSettingsClusterLimits(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.AutoscalerAutoscalerSettingsClusterLimitsCpu'] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param 'AutoscalerAutoscalerSettingsClusterLimitsCpuArgs' cpu: defines the minimum and maximum amount of CPUs for cluster's worker nodes.
        :param _builtins.bool enabled: enable/disable cluster size limits policy.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.AutoscalerAutoscalerSettingsClusterLimitsCpu']:
        """
        defines the minimum and maximum amount of CPUs for cluster's worker nodes.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable cluster size limits policy.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AutoscalerAutoscalerSettingsClusterLimitsCpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCores":
            suggest = "max_cores"
        elif key == "minCores":
            suggest = "min_cores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsClusterLimitsCpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsClusterLimitsCpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsClusterLimitsCpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_cores: Optional[_builtins.int] = None,
                 min_cores: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_cores: defines the maximum allowed amount of vCPUs in the whole cluster.
        :param _builtins.int min_cores: defines the minimum allowed amount of CPUs in the whole cluster.
        """
        if max_cores is not None:
            pulumi.set(__self__, "max_cores", max_cores)
        if min_cores is not None:
            pulumi.set(__self__, "min_cores", min_cores)

    @_builtins.property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> Optional[_builtins.int]:
        """
        defines the maximum allowed amount of vCPUs in the whole cluster.
        """
        return pulumi.get(self, "max_cores")

    @_builtins.property
    @pulumi.getter(name="minCores")
    def min_cores(self) -> Optional[_builtins.int]:
        """
        defines the minimum allowed amount of CPUs in the whole cluster.
        """
        return pulumi.get(self, "min_cores")


@pulumi.output_type
class AutoscalerAutoscalerSettingsNodeDownscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emptyNodes":
            suggest = "empty_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsNodeDownscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsNodeDownscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsNodeDownscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 empty_nodes: Optional['outputs.AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 evictor: Optional['outputs.AutoscalerAutoscalerSettingsNodeDownscalerEvictor'] = None):
        """
        :param 'AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs' empty_nodes: defines whether Node Downscaler should opt in for removing empty worker nodes when possible.
        :param _builtins.bool enabled: enable/disable node downscaler policy.
        :param 'AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs' evictor: defines the CAST AI Evictor component settings. Evictor watches the pods running in your cluster and looks for ways to compact them into fewer nodes, making nodes empty, which will be removed by the empty worker nodes policy.
        """
        if empty_nodes is not None:
            pulumi.set(__self__, "empty_nodes", empty_nodes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if evictor is not None:
            pulumi.set(__self__, "evictor", evictor)

    @_builtins.property
    @pulumi.getter(name="emptyNodes")
    def empty_nodes(self) -> Optional['outputs.AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes']:
        """
        defines whether Node Downscaler should opt in for removing empty worker nodes when possible.
        """
        return pulumi.get(self, "empty_nodes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable node downscaler policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def evictor(self) -> Optional['outputs.AutoscalerAutoscalerSettingsNodeDownscalerEvictor']:
        """
        defines the CAST AI Evictor component settings. Evictor watches the pods running in your cluster and looks for ways to compact them into fewer nodes, making nodes empty, which will be removed by the empty worker nodes policy.
        """
        return pulumi.get(self, "evictor")


@pulumi.output_type
class AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delaySeconds":
            suggest = "delay_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_seconds: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int delay_seconds: period (in seconds) to wait before removing the node. Might be useful to control the aggressiveness of the downscaler.
        :param _builtins.bool enabled: enable/disable the empty worker nodes policy.
        """
        if delay_seconds is not None:
            pulumi.set(__self__, "delay_seconds", delay_seconds)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="delaySeconds")
    def delay_seconds(self) -> Optional[_builtins.int]:
        """
        period (in seconds) to wait before removing the node. Might be useful to control the aggressiveness of the downscaler.
        """
        return pulumi.get(self, "delay_seconds")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable the empty worker nodes policy.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AutoscalerAutoscalerSettingsNodeDownscalerEvictor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggressiveMode":
            suggest = "aggressive_mode"
        elif key == "cycleInterval":
            suggest = "cycle_interval"
        elif key == "dryRun":
            suggest = "dry_run"
        elif key == "ignorePodDisruptionBudgets":
            suggest = "ignore_pod_disruption_budgets"
        elif key == "nodeGracePeriodMinutes":
            suggest = "node_grace_period_minutes"
        elif key == "podEvictionFailureBackOffInterval":
            suggest = "pod_eviction_failure_back_off_interval"
        elif key == "scopedMode":
            suggest = "scoped_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsNodeDownscalerEvictor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsNodeDownscalerEvictor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsNodeDownscalerEvictor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggressive_mode: Optional[_builtins.bool] = None,
                 cycle_interval: Optional[_builtins.str] = None,
                 dry_run: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 ignore_pod_disruption_budgets: Optional[_builtins.bool] = None,
                 node_grace_period_minutes: Optional[_builtins.int] = None,
                 pod_eviction_failure_back_off_interval: Optional[_builtins.str] = None,
                 scoped_mode: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool aggressive_mode: enable/disable aggressive mode. By default, Evictor does not target nodes that are running unreplicated pods. This mode will make the Evictor start considering application with just a single replica.
        :param _builtins.str cycle_interval: configure the interval duration between Evictor operations. This property can be used to lower or raise the frequency of the Evictor's find-and-drain operations.
        :param _builtins.bool dry_run: enable/disable dry-run. This property allows you to prevent the Evictor from carrying any operations out and preview the actions it would take.
        :param _builtins.bool enabled: enable/disable the Evictor policy. This will either install or uninstall the Evictor component in your cluster.
        :param _builtins.bool ignore_pod_disruption_budgets: if enabled then Evictor will attempt to evict pods that have pod disruption budgets configured.
        :param _builtins.int node_grace_period_minutes: configure the node grace period which controls the duration which must pass after a node has been created before Evictor starts considering that node.
        :param _builtins.str pod_eviction_failure_back_off_interval: configure the pod eviction failure back off interval. If pod eviction fails then Evictor will attempt to evict it again after the amount of time specified here.
        :param _builtins.bool scoped_mode: enable/disable scoped mode. By default, Evictor targets all nodes in the cluster. This mode will constrain it to just the nodes which were created by CAST AI.
        """
        if aggressive_mode is not None:
            pulumi.set(__self__, "aggressive_mode", aggressive_mode)
        if cycle_interval is not None:
            pulumi.set(__self__, "cycle_interval", cycle_interval)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ignore_pod_disruption_budgets is not None:
            pulumi.set(__self__, "ignore_pod_disruption_budgets", ignore_pod_disruption_budgets)
        if node_grace_period_minutes is not None:
            pulumi.set(__self__, "node_grace_period_minutes", node_grace_period_minutes)
        if pod_eviction_failure_back_off_interval is not None:
            pulumi.set(__self__, "pod_eviction_failure_back_off_interval", pod_eviction_failure_back_off_interval)
        if scoped_mode is not None:
            pulumi.set(__self__, "scoped_mode", scoped_mode)

    @_builtins.property
    @pulumi.getter(name="aggressiveMode")
    def aggressive_mode(self) -> Optional[_builtins.bool]:
        """
        enable/disable aggressive mode. By default, Evictor does not target nodes that are running unreplicated pods. This mode will make the Evictor start considering application with just a single replica.
        """
        return pulumi.get(self, "aggressive_mode")

    @_builtins.property
    @pulumi.getter(name="cycleInterval")
    def cycle_interval(self) -> Optional[_builtins.str]:
        """
        configure the interval duration between Evictor operations. This property can be used to lower or raise the frequency of the Evictor's find-and-drain operations.
        """
        return pulumi.get(self, "cycle_interval")

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[_builtins.bool]:
        """
        enable/disable dry-run. This property allows you to prevent the Evictor from carrying any operations out and preview the actions it would take.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable the Evictor policy. This will either install or uninstall the Evictor component in your cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="ignorePodDisruptionBudgets")
    def ignore_pod_disruption_budgets(self) -> Optional[_builtins.bool]:
        """
        if enabled then Evictor will attempt to evict pods that have pod disruption budgets configured.
        """
        return pulumi.get(self, "ignore_pod_disruption_budgets")

    @_builtins.property
    @pulumi.getter(name="nodeGracePeriodMinutes")
    def node_grace_period_minutes(self) -> Optional[_builtins.int]:
        """
        configure the node grace period which controls the duration which must pass after a node has been created before Evictor starts considering that node.
        """
        return pulumi.get(self, "node_grace_period_minutes")

    @_builtins.property
    @pulumi.getter(name="podEvictionFailureBackOffInterval")
    def pod_eviction_failure_back_off_interval(self) -> Optional[_builtins.str]:
        """
        configure the pod eviction failure back off interval. If pod eviction fails then Evictor will attempt to evict it again after the amount of time specified here.
        """
        return pulumi.get(self, "pod_eviction_failure_back_off_interval")

    @_builtins.property
    @pulumi.getter(name="scopedMode")
    def scoped_mode(self) -> Optional[_builtins.bool]:
        """
        enable/disable scoped mode. By default, Evictor targets all nodes in the cluster. This mode will constrain it to just the nodes which were created by CAST AI.
        """
        return pulumi.get(self, "scoped_mode")


@pulumi.output_type
class AutoscalerAutoscalerSettingsSpotInstances(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReclaimRate":
            suggest = "max_reclaim_rate"
        elif key == "spotBackups":
            suggest = "spot_backups"
        elif key == "spotDiversityEnabled":
            suggest = "spot_diversity_enabled"
        elif key == "spotDiversityPriceIncreaseLimit":
            suggest = "spot_diversity_price_increase_limit"
        elif key == "spotInterruptionPredictions":
            suggest = "spot_interruption_predictions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsSpotInstances. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsSpotInstances.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsSpotInstances.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 max_reclaim_rate: Optional[_builtins.int] = None,
                 spot_backups: Optional['outputs.AutoscalerAutoscalerSettingsSpotInstancesSpotBackups'] = None,
                 spot_diversity_enabled: Optional[_builtins.bool] = None,
                 spot_diversity_price_increase_limit: Optional[_builtins.int] = None,
                 spot_interruption_predictions: Optional['outputs.AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions'] = None):
        """
        :param _builtins.bool enabled: enable/disable spot instances policy.
        :param _builtins.int max_reclaim_rate: max allowed reclaim rate when choosing spot instance type. E.g. if the value is 10%, instance types having 10% or higher reclaim rate will not be considered. Set to zero to use all instance types regardless of reclaim rate.
        :param 'AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs' spot_backups: policy defining whether autoscaler can use spot backups instead of spot instances when spot instances are not available.
        :param _builtins.bool spot_diversity_enabled: enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        :param _builtins.int spot_diversity_price_increase_limit: allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        :param 'AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs' spot_interruption_predictions: configure the handling of SPOT interruption predictions.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_reclaim_rate is not None:
            pulumi.set(__self__, "max_reclaim_rate", max_reclaim_rate)
        if spot_backups is not None:
            pulumi.set(__self__, "spot_backups", spot_backups)
        if spot_diversity_enabled is not None:
            pulumi.set(__self__, "spot_diversity_enabled", spot_diversity_enabled)
        if spot_diversity_price_increase_limit is not None:
            pulumi.set(__self__, "spot_diversity_price_increase_limit", spot_diversity_price_increase_limit)
        if spot_interruption_predictions is not None:
            pulumi.set(__self__, "spot_interruption_predictions", spot_interruption_predictions)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`enabled` under `spot_instances` is deprecated. To enable spot instances, set `constraints.spot = true` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable spot instances policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxReclaimRate")
    @_utilities.deprecated("""`max_reclaim_rate` under `spot_instances` is deprecated. This field has no direct equivalent in the config.NodeTemplate resource, and setting it will have no effect.""")
    def max_reclaim_rate(self) -> Optional[_builtins.int]:
        """
        max allowed reclaim rate when choosing spot instance type. E.g. if the value is 10%, instance types having 10% or higher reclaim rate will not be considered. Set to zero to use all instance types regardless of reclaim rate.
        """
        return pulumi.get(self, "max_reclaim_rate")

    @_builtins.property
    @pulumi.getter(name="spotBackups")
    @_utilities.deprecated("""`spot_backups` under `spot_instances` is deprecated. Configure spot backup behavior using `constraints.use_spot_fallbacks` and `constraints.fallback_restore_rate_seconds` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_backups(self) -> Optional['outputs.AutoscalerAutoscalerSettingsSpotInstancesSpotBackups']:
        """
        policy defining whether autoscaler can use spot backups instead of spot instances when spot instances are not available.
        """
        return pulumi.get(self, "spot_backups")

    @_builtins.property
    @pulumi.getter(name="spotDiversityEnabled")
    @_utilities.deprecated("""`spot_diversity_enabled` is deprecated. Use the `enable_spot_diversity` field within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_diversity_enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        """
        return pulumi.get(self, "spot_diversity_enabled")

    @_builtins.property
    @pulumi.getter(name="spotDiversityPriceIncreaseLimit")
    @_utilities.deprecated("""`spot_diversity_price_increase_limit` is deprecated. Use `spot_diversity_price_increase_limit_percent` within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_diversity_price_increase_limit(self) -> Optional[_builtins.int]:
        """
        allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        """
        return pulumi.get(self, "spot_diversity_price_increase_limit")

    @_builtins.property
    @pulumi.getter(name="spotInterruptionPredictions")
    @_utilities.deprecated("""`spot_interruption_predictions` is deprecated. Use the `spot_interruption_predictions_enabled` and `spot_interruption_predictions_type` fields in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_interruption_predictions(self) -> Optional['outputs.AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions']:
        """
        configure the handling of SPOT interruption predictions.
        """
        return pulumi.get(self, "spot_interruption_predictions")


@pulumi.output_type
class AutoscalerAutoscalerSettingsSpotInstancesSpotBackups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotBackupRestoreRateSeconds":
            suggest = "spot_backup_restore_rate_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsSpotInstancesSpotBackups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsSpotInstancesSpotBackups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsSpotInstancesSpotBackups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 spot_backup_restore_rate_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: enable/disable spot backups policy.
        :param _builtins.int spot_backup_restore_rate_seconds: defines interval on how often spot backups restore to real spot should occur.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if spot_backup_restore_rate_seconds is not None:
            pulumi.set(__self__, "spot_backup_restore_rate_seconds", spot_backup_restore_rate_seconds)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable spot backups policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="spotBackupRestoreRateSeconds")
    def spot_backup_restore_rate_seconds(self) -> Optional[_builtins.int]:
        """
        defines interval on how often spot backups restore to real spot should occur.
        """
        return pulumi.get(self, "spot_backup_restore_rate_seconds")


@pulumi.output_type
class AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotInterruptionPredictionsType":
            suggest = "spot_interruption_predictions_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 spot_interruption_predictions_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: enable/disable spot interruption predictions.
        :param _builtins.str spot_interruption_predictions_type: define the type of the spot interruption prediction to handle. Allowed values are AWSRebalanceRecommendations, CASTAIInterruptionPredictions.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if spot_interruption_predictions_type is not None:
            pulumi.set(__self__, "spot_interruption_predictions_type", spot_interruption_predictions_type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable spot interruption predictions.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="spotInterruptionPredictionsType")
    def spot_interruption_predictions_type(self) -> Optional[_builtins.str]:
        """
        define the type of the spot interruption prediction to handle. Allowed values are AWSRebalanceRecommendations, CASTAIInterruptionPredictions.
        """
        return pulumi.get(self, "spot_interruption_predictions_type")


@pulumi.output_type
class AutoscalerAutoscalerSettingsUnschedulablePods(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customInstancesEnabled":
            suggest = "custom_instances_enabled"
        elif key == "headroomSpot":
            suggest = "headroom_spot"
        elif key == "nodeConstraints":
            suggest = "node_constraints"
        elif key == "podPinner":
            suggest = "pod_pinner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsUnschedulablePods. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePods.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePods.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_instances_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 headroom: Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom'] = None,
                 headroom_spot: Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot'] = None,
                 node_constraints: Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints'] = None,
                 pod_pinner: Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsPodPinner'] = None):
        """
        :param _builtins.bool custom_instances_enabled: enable/disable custom instances policy.
        :param _builtins.bool enabled: enable/disable unschedulable pods detection policy.
        :param 'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs' headroom: additional headroom based on cluster's total available capacity for on-demand nodes.
        :param 'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs' headroom_spot: additional headroom based on cluster's total available capacity for spot nodes.
        :param 'AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs' node_constraints: defines the node constraints that will be applied when autoscaling with Unschedulable Pods policy.
        :param 'AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs' pod_pinner: defines the Cast AI Pod Pinner components settings.
        """
        if custom_instances_enabled is not None:
            pulumi.set(__self__, "custom_instances_enabled", custom_instances_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headroom is not None:
            pulumi.set(__self__, "headroom", headroom)
        if headroom_spot is not None:
            pulumi.set(__self__, "headroom_spot", headroom_spot)
        if node_constraints is not None:
            pulumi.set(__self__, "node_constraints", node_constraints)
        if pod_pinner is not None:
            pulumi.set(__self__, "pod_pinner", pod_pinner)

    @_builtins.property
    @pulumi.getter(name="customInstancesEnabled")
    @_utilities.deprecated("""`custom_instances_enabled` under `unschedulable_pods.node_constraints` is deprecated. Use the `custom_instances_enabled` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""")
    def custom_instances_enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable custom instances policy.
        """
        return pulumi.get(self, "custom_instances_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable unschedulable pods detection policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`headroom` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""")
    def headroom(self) -> Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom']:
        """
        additional headroom based on cluster's total available capacity for on-demand nodes.
        """
        return pulumi.get(self, "headroom")

    @_builtins.property
    @pulumi.getter(name="headroomSpot")
    @_utilities.deprecated("""`headroom_spot` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""")
    def headroom_spot(self) -> Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot']:
        """
        additional headroom based on cluster's total available capacity for spot nodes.
        """
        return pulumi.get(self, "headroom_spot")

    @_builtins.property
    @pulumi.getter(name="nodeConstraints")
    @_utilities.deprecated("""`node_constraints` under `unschedulable_pods` is deprecated. Use the `constraints` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""")
    def node_constraints(self) -> Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints']:
        """
        defines the node constraints that will be applied when autoscaling with Unschedulable Pods policy.
        """
        return pulumi.get(self, "node_constraints")

    @_builtins.property
    @pulumi.getter(name="podPinner")
    def pod_pinner(self) -> Optional['outputs.AutoscalerAutoscalerSettingsUnschedulablePodsPodPinner']:
        """
        defines the Cast AI Pod Pinner components settings.
        """
        return pulumi.get(self, "pod_pinner")


@pulumi.output_type
class AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPercentage":
            suggest = "cpu_percentage"
        elif key == "memoryPercentage":
            suggest = "memory_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePodsHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_percentage: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 memory_percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.int cpu_percentage: defines percentage of additional CPU capacity to be added.
        :param _builtins.bool enabled: enable/disable headroom policy.
        :param _builtins.int memory_percentage: defines percentage of additional memory capacity to be added.
        """
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[_builtins.int]:
        """
        defines percentage of additional CPU capacity to be added.
        """
        return pulumi.get(self, "cpu_percentage")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable headroom policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[_builtins.int]:
        """
        defines percentage of additional memory capacity to be added.
        """
        return pulumi.get(self, "memory_percentage")


@pulumi.output_type
class AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPercentage":
            suggest = "cpu_percentage"
        elif key == "memoryPercentage":
            suggest = "memory_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_percentage: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 memory_percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.int cpu_percentage: defines percentage of additional CPU capacity to be added.
        :param _builtins.bool enabled: enable/disable headroom_spot policy.
        :param _builtins.int memory_percentage: defines percentage of additional memory capacity to be added.
        """
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[_builtins.int]:
        """
        defines percentage of additional CPU capacity to be added.
        """
        return pulumi.get(self, "cpu_percentage")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable headroom_spot policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[_builtins.int]:
        """
        defines percentage of additional memory capacity to be added.
        """
        return pulumi.get(self, "memory_percentage")


@pulumi.output_type
class AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCpuCores":
            suggest = "max_cpu_cores"
        elif key == "maxRamMib":
            suggest = "max_ram_mib"
        elif key == "minCpuCores":
            suggest = "min_cpu_cores"
        elif key == "minRamMib":
            suggest = "min_ram_mib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 max_cpu_cores: Optional[_builtins.int] = None,
                 max_ram_mib: Optional[_builtins.int] = None,
                 min_cpu_cores: Optional[_builtins.int] = None,
                 min_ram_mib: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: enable/disable node constraints policy.
        :param _builtins.int max_cpu_cores: defines max CPU cores for the node to pick.
        :param _builtins.int max_ram_mib: defines max RAM in MiB for the node to pick.
        :param _builtins.int min_cpu_cores: defines min CPU cores for the node to pick.
        :param _builtins.int min_ram_mib: defines min RAM in MiB for the node to pick.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_cpu_cores is not None:
            pulumi.set(__self__, "max_cpu_cores", max_cpu_cores)
        if max_ram_mib is not None:
            pulumi.set(__self__, "max_ram_mib", max_ram_mib)
        if min_cpu_cores is not None:
            pulumi.set(__self__, "min_cpu_cores", min_cpu_cores)
        if min_ram_mib is not None:
            pulumi.set(__self__, "min_ram_mib", min_ram_mib)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable node constraints policy.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxCpuCores")
    def max_cpu_cores(self) -> Optional[_builtins.int]:
        """
        defines max CPU cores for the node to pick.
        """
        return pulumi.get(self, "max_cpu_cores")

    @_builtins.property
    @pulumi.getter(name="maxRamMib")
    def max_ram_mib(self) -> Optional[_builtins.int]:
        """
        defines max RAM in MiB for the node to pick.
        """
        return pulumi.get(self, "max_ram_mib")

    @_builtins.property
    @pulumi.getter(name="minCpuCores")
    def min_cpu_cores(self) -> Optional[_builtins.int]:
        """
        defines min CPU cores for the node to pick.
        """
        return pulumi.get(self, "min_cpu_cores")

    @_builtins.property
    @pulumi.getter(name="minRamMib")
    def min_ram_mib(self) -> Optional[_builtins.int]:
        """
        defines min RAM in MiB for the node to pick.
        """
        return pulumi.get(self, "min_ram_mib")


@pulumi.output_type
class AutoscalerAutoscalerSettingsUnschedulablePodsPodPinner(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: enable/disable the Pod Pinner component's automatic management in your cluster. Default: enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        enable/disable the Pod Pinner component's automatic management in your cluster. Default: enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EvictorAdvancedConfigEvictorAdvancedConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelectors":
            suggest = "node_selectors"
        elif key == "podSelectors":
            suggest = "pod_selectors"
        elif key == "removalDisabled":
            suggest = "removal_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvictorAdvancedConfigEvictorAdvancedConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvictorAdvancedConfigEvictorAdvancedConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvictorAdvancedConfigEvictorAdvancedConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggressive: Optional[_builtins.bool] = None,
                 disposable: Optional[_builtins.bool] = None,
                 node_selectors: Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector']] = None,
                 pod_selectors: Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigPodSelector']] = None,
                 removal_disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool aggressive: Apply Aggressive mode to Evictor
        :param _builtins.bool disposable: Mark node as disposable
        :param Sequence['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs'] node_selectors: node selector
        :param Sequence['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs'] pod_selectors: pod selector
        :param _builtins.bool removal_disabled: Mark pods as removal disabled
        """
        if aggressive is not None:
            pulumi.set(__self__, "aggressive", aggressive)
        if disposable is not None:
            pulumi.set(__self__, "disposable", disposable)
        if node_selectors is not None:
            pulumi.set(__self__, "node_selectors", node_selectors)
        if pod_selectors is not None:
            pulumi.set(__self__, "pod_selectors", pod_selectors)
        if removal_disabled is not None:
            pulumi.set(__self__, "removal_disabled", removal_disabled)

    @_builtins.property
    @pulumi.getter
    def aggressive(self) -> Optional[_builtins.bool]:
        """
        Apply Aggressive mode to Evictor
        """
        return pulumi.get(self, "aggressive")

    @_builtins.property
    @pulumi.getter
    def disposable(self) -> Optional[_builtins.bool]:
        """
        Mark node as disposable
        """
        return pulumi.get(self, "disposable")

    @_builtins.property
    @pulumi.getter(name="nodeSelectors")
    def node_selectors(self) -> Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector']]:
        """
        node selector
        """
        return pulumi.get(self, "node_selectors")

    @_builtins.property
    @pulumi.getter(name="podSelectors")
    def pod_selectors(self) -> Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigPodSelector']]:
        """
        pod selector
        """
        return pulumi.get(self, "pod_selectors")

    @_builtins.property
    @pulumi.getter(name="removalDisabled")
    def removal_disabled(self) -> Optional[_builtins.bool]:
        """
        Mark pods as removal disabled
        """
        return pulumi.get(self, "removal_disabled")


@pulumi.output_type
class EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvictorAdvancedConfigEvictorAdvancedConfigNodeSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class EvictorAdvancedConfigEvictorAdvancedConfigPodSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvictorAdvancedConfigEvictorAdvancedConfigPodSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvictorAdvancedConfigEvictorAdvancedConfigPodSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvictorAdvancedConfigEvictorAdvancedConfigPodSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 match_expressions: Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None,
                 namespace: Optional[_builtins.str] = None):
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "match_labels")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")


