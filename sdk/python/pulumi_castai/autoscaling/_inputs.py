# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AutoscalerAutoscalerSettingsArgs',
    'AutoscalerAutoscalerSettingsArgsDict',
    'AutoscalerAutoscalerSettingsClusterLimitsArgs',
    'AutoscalerAutoscalerSettingsClusterLimitsArgsDict',
    'AutoscalerAutoscalerSettingsClusterLimitsCpuArgs',
    'AutoscalerAutoscalerSettingsClusterLimitsCpuArgsDict',
    'AutoscalerAutoscalerSettingsNodeDownscalerArgs',
    'AutoscalerAutoscalerSettingsNodeDownscalerArgsDict',
    'AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs',
    'AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgsDict',
    'AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs',
    'AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgsDict',
    'AutoscalerAutoscalerSettingsSpotInstancesArgs',
    'AutoscalerAutoscalerSettingsSpotInstancesArgsDict',
    'AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs',
    'AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgsDict',
    'AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs',
    'AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgsDict',
    'AutoscalerAutoscalerSettingsUnschedulablePodsArgs',
    'AutoscalerAutoscalerSettingsUnschedulablePodsArgsDict',
    'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs',
    'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgsDict',
    'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs',
    'AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgsDict',
    'AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs',
    'AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgsDict',
    'AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs',
    'AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgsDict',
    'EvictorAdvancedConfigEvictorAdvancedConfigArgs',
    'EvictorAdvancedConfigEvictorAdvancedConfigArgsDict',
    'EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs',
    'EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgsDict',
    'EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgs',
    'EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgsDict',
    'EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs',
    'EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgsDict',
    'EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgs',
    'EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgsDict',
]

MYPY = False

if not MYPY:
    class AutoscalerAutoscalerSettingsArgsDict(TypedDict):
        cluster_limits: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsArgsDict']]
        """
        defines minimum and maximum amount of CPU the cluster can have.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable autoscaler policies
        """
        is_scoped_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        run autoscaler in scoped mode. Only marked pods and nodes will be considered.
        """
        node_downscaler: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerArgsDict']]
        """
        node downscaler defines policies for removing nodes based on the configured conditions.
        """
        node_templates_partial_matching_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        marks whether partial matching should be used when deciding which custom node template to select.
        """
        spot_instances: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesArgsDict']]
        """
        policy defining whether autoscaler can use spot instances for provisioning additional workloads.
        """
        unschedulable_pods: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsArgsDict']]
        """
        policy defining autoscaler's behavior when unschedulable pods were detected.
        """
elif False:
    AutoscalerAutoscalerSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsArgs:
    def __init__(__self__, *,
                 cluster_limits: Optional[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_scoped_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_downscaler: Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerArgs']] = None,
                 node_templates_partial_matching_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_instances: Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesArgs']] = None,
                 unschedulable_pods: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsArgs']] = None):
        """
        :param pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsArgs'] cluster_limits: defines minimum and maximum amount of CPU the cluster can have.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable autoscaler policies
        :param pulumi.Input[_builtins.bool] is_scoped_mode: run autoscaler in scoped mode. Only marked pods and nodes will be considered.
        :param pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerArgs'] node_downscaler: node downscaler defines policies for removing nodes based on the configured conditions.
        :param pulumi.Input[_builtins.bool] node_templates_partial_matching_enabled: marks whether partial matching should be used when deciding which custom node template to select.
        :param pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesArgs'] spot_instances: policy defining whether autoscaler can use spot instances for provisioning additional workloads.
        :param pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsArgs'] unschedulable_pods: policy defining autoscaler's behavior when unschedulable pods were detected.
        """
        if cluster_limits is not None:
            pulumi.set(__self__, "cluster_limits", cluster_limits)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if is_scoped_mode is not None:
            pulumi.set(__self__, "is_scoped_mode", is_scoped_mode)
        if node_downscaler is not None:
            pulumi.set(__self__, "node_downscaler", node_downscaler)
        if node_templates_partial_matching_enabled is not None:
            pulumi.set(__self__, "node_templates_partial_matching_enabled", node_templates_partial_matching_enabled)
        if spot_instances is not None:
            warnings.warn("""`spot_instances` is deprecated. Configure spot instance settings using the `constraints` field in the default config.NodeTemplate resource. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""spot_instances is deprecated: `spot_instances` is deprecated. Configure spot instance settings using the `constraints` field in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
        if spot_instances is not None:
            pulumi.set(__self__, "spot_instances", spot_instances)
        if unschedulable_pods is not None:
            pulumi.set(__self__, "unschedulable_pods", unschedulable_pods)

    @_builtins.property
    @pulumi.getter(name="clusterLimits")
    def cluster_limits(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsArgs']]:
        """
        defines minimum and maximum amount of CPU the cluster can have.
        """
        return pulumi.get(self, "cluster_limits")

    @cluster_limits.setter
    def cluster_limits(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsArgs']]):
        pulumi.set(self, "cluster_limits", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable autoscaler policies
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="isScopedMode")
    def is_scoped_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        run autoscaler in scoped mode. Only marked pods and nodes will be considered.
        """
        return pulumi.get(self, "is_scoped_mode")

    @is_scoped_mode.setter
    def is_scoped_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_scoped_mode", value)

    @_builtins.property
    @pulumi.getter(name="nodeDownscaler")
    def node_downscaler(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerArgs']]:
        """
        node downscaler defines policies for removing nodes based on the configured conditions.
        """
        return pulumi.get(self, "node_downscaler")

    @node_downscaler.setter
    def node_downscaler(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerArgs']]):
        pulumi.set(self, "node_downscaler", value)

    @_builtins.property
    @pulumi.getter(name="nodeTemplatesPartialMatchingEnabled")
    def node_templates_partial_matching_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        marks whether partial matching should be used when deciding which custom node template to select.
        """
        return pulumi.get(self, "node_templates_partial_matching_enabled")

    @node_templates_partial_matching_enabled.setter
    def node_templates_partial_matching_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "node_templates_partial_matching_enabled", value)

    @_builtins.property
    @pulumi.getter(name="spotInstances")
    @_utilities.deprecated("""`spot_instances` is deprecated. Configure spot instance settings using the `constraints` field in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_instances(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesArgs']]:
        """
        policy defining whether autoscaler can use spot instances for provisioning additional workloads.
        """
        return pulumi.get(self, "spot_instances")

    @spot_instances.setter
    def spot_instances(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesArgs']]):
        pulumi.set(self, "spot_instances", value)

    @_builtins.property
    @pulumi.getter(name="unschedulablePods")
    def unschedulable_pods(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsArgs']]:
        """
        policy defining autoscaler's behavior when unschedulable pods were detected.
        """
        return pulumi.get(self, "unschedulable_pods")

    @unschedulable_pods.setter
    def unschedulable_pods(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsArgs']]):
        pulumi.set(self, "unschedulable_pods", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsClusterLimitsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsCpuArgsDict']]
        """
        defines the minimum and maximum amount of CPUs for cluster's worker nodes.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable cluster size limits policy.
        """
elif False:
    AutoscalerAutoscalerSettingsClusterLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsClusterLimitsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsCpuArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsCpuArgs'] cpu: defines the minimum and maximum amount of CPUs for cluster's worker nodes.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable cluster size limits policy.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsCpuArgs']]:
        """
        defines the minimum and maximum amount of CPUs for cluster's worker nodes.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsClusterLimitsCpuArgs']]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable cluster size limits policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsClusterLimitsCpuArgsDict(TypedDict):
        max_cores: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines the maximum allowed amount of vCPUs in the whole cluster.
        """
        min_cores: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines the minimum allowed amount of CPUs in the whole cluster.
        """
elif False:
    AutoscalerAutoscalerSettingsClusterLimitsCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsClusterLimitsCpuArgs:
    def __init__(__self__, *,
                 max_cores: Optional[pulumi.Input[_builtins.int]] = None,
                 min_cores: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_cores: defines the maximum allowed amount of vCPUs in the whole cluster.
        :param pulumi.Input[_builtins.int] min_cores: defines the minimum allowed amount of CPUs in the whole cluster.
        """
        if max_cores is not None:
            pulumi.set(__self__, "max_cores", max_cores)
        if min_cores is not None:
            pulumi.set(__self__, "min_cores", min_cores)

    @_builtins.property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines the maximum allowed amount of vCPUs in the whole cluster.
        """
        return pulumi.get(self, "max_cores")

    @max_cores.setter
    def max_cores(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_cores", value)

    @_builtins.property
    @pulumi.getter(name="minCores")
    def min_cores(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines the minimum allowed amount of CPUs in the whole cluster.
        """
        return pulumi.get(self, "min_cores")

    @min_cores.setter
    def min_cores(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_cores", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsNodeDownscalerArgsDict(TypedDict):
        empty_nodes: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgsDict']]
        """
        defines whether Node Downscaler should opt in for removing empty worker nodes when possible.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable node downscaler policy.
        """
        evictor: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgsDict']]
        """
        defines the CAST AI Evictor component settings. Evictor watches the pods running in your cluster and looks for ways to compact them into fewer nodes, making nodes empty, which will be removed by the empty worker nodes policy.
        """
elif False:
    AutoscalerAutoscalerSettingsNodeDownscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsNodeDownscalerArgs:
    def __init__(__self__, *,
                 empty_nodes: Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 evictor: Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs']] = None):
        """
        :param pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs'] empty_nodes: defines whether Node Downscaler should opt in for removing empty worker nodes when possible.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable node downscaler policy.
        :param pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs'] evictor: defines the CAST AI Evictor component settings. Evictor watches the pods running in your cluster and looks for ways to compact them into fewer nodes, making nodes empty, which will be removed by the empty worker nodes policy.
        """
        if empty_nodes is not None:
            pulumi.set(__self__, "empty_nodes", empty_nodes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if evictor is not None:
            pulumi.set(__self__, "evictor", evictor)

    @_builtins.property
    @pulumi.getter(name="emptyNodes")
    def empty_nodes(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs']]:
        """
        defines whether Node Downscaler should opt in for removing empty worker nodes when possible.
        """
        return pulumi.get(self, "empty_nodes")

    @empty_nodes.setter
    def empty_nodes(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs']]):
        pulumi.set(self, "empty_nodes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable node downscaler policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def evictor(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs']]:
        """
        defines the CAST AI Evictor component settings. Evictor watches the pods running in your cluster and looks for ways to compact them into fewer nodes, making nodes empty, which will be removed by the empty worker nodes policy.
        """
        return pulumi.get(self, "evictor")

    @evictor.setter
    def evictor(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs']]):
        pulumi.set(self, "evictor", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgsDict(TypedDict):
        delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        period (in seconds) to wait before removing the node. Might be useful to control the aggressiveness of the downscaler.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable the empty worker nodes policy.
        """
elif False:
    AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsNodeDownscalerEmptyNodesArgs:
    def __init__(__self__, *,
                 delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] delay_seconds: period (in seconds) to wait before removing the node. Might be useful to control the aggressiveness of the downscaler.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable the empty worker nodes policy.
        """
        if delay_seconds is not None:
            pulumi.set(__self__, "delay_seconds", delay_seconds)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="delaySeconds")
    def delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        period (in seconds) to wait before removing the node. Might be useful to control the aggressiveness of the downscaler.
        """
        return pulumi.get(self, "delay_seconds")

    @delay_seconds.setter
    def delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay_seconds", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable the empty worker nodes policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgsDict(TypedDict):
        aggressive_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable aggressive mode. By default, Evictor does not target nodes that are running unreplicated pods. This mode will make the Evictor start considering application with just a single replica.
        """
        cycle_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        configure the interval duration between Evictor operations. This property can be used to lower or raise the frequency of the Evictor's find-and-drain operations.
        """
        dry_run: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable dry-run. This property allows you to prevent the Evictor from carrying any operations out and preview the actions it would take.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable the Evictor policy. This will either install or uninstall the Evictor component in your cluster.
        """
        ignore_pod_disruption_budgets: NotRequired[pulumi.Input[_builtins.bool]]
        """
        if enabled then Evictor will attempt to evict pods that have pod disruption budgets configured.
        """
        node_grace_period_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        configure the node grace period which controls the duration which must pass after a node has been created before Evictor starts considering that node.
        """
        pod_eviction_failure_back_off_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        configure the pod eviction failure back off interval. If pod eviction fails then Evictor will attempt to evict it again after the amount of time specified here.
        """
        scoped_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable scoped mode. By default, Evictor targets all nodes in the cluster. This mode will constrain it to just the nodes which were created by CAST AI.
        """
elif False:
    AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsNodeDownscalerEvictorArgs:
    def __init__(__self__, *,
                 aggressive_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 cycle_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 dry_run: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ignore_pod_disruption_budgets: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_grace_period_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 pod_eviction_failure_back_off_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 scoped_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] aggressive_mode: enable/disable aggressive mode. By default, Evictor does not target nodes that are running unreplicated pods. This mode will make the Evictor start considering application with just a single replica.
        :param pulumi.Input[_builtins.str] cycle_interval: configure the interval duration between Evictor operations. This property can be used to lower or raise the frequency of the Evictor's find-and-drain operations.
        :param pulumi.Input[_builtins.bool] dry_run: enable/disable dry-run. This property allows you to prevent the Evictor from carrying any operations out and preview the actions it would take.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable the Evictor policy. This will either install or uninstall the Evictor component in your cluster.
        :param pulumi.Input[_builtins.bool] ignore_pod_disruption_budgets: if enabled then Evictor will attempt to evict pods that have pod disruption budgets configured.
        :param pulumi.Input[_builtins.int] node_grace_period_minutes: configure the node grace period which controls the duration which must pass after a node has been created before Evictor starts considering that node.
        :param pulumi.Input[_builtins.str] pod_eviction_failure_back_off_interval: configure the pod eviction failure back off interval. If pod eviction fails then Evictor will attempt to evict it again after the amount of time specified here.
        :param pulumi.Input[_builtins.bool] scoped_mode: enable/disable scoped mode. By default, Evictor targets all nodes in the cluster. This mode will constrain it to just the nodes which were created by CAST AI.
        """
        if aggressive_mode is not None:
            pulumi.set(__self__, "aggressive_mode", aggressive_mode)
        if cycle_interval is not None:
            pulumi.set(__self__, "cycle_interval", cycle_interval)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ignore_pod_disruption_budgets is not None:
            pulumi.set(__self__, "ignore_pod_disruption_budgets", ignore_pod_disruption_budgets)
        if node_grace_period_minutes is not None:
            pulumi.set(__self__, "node_grace_period_minutes", node_grace_period_minutes)
        if pod_eviction_failure_back_off_interval is not None:
            pulumi.set(__self__, "pod_eviction_failure_back_off_interval", pod_eviction_failure_back_off_interval)
        if scoped_mode is not None:
            pulumi.set(__self__, "scoped_mode", scoped_mode)

    @_builtins.property
    @pulumi.getter(name="aggressiveMode")
    def aggressive_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable aggressive mode. By default, Evictor does not target nodes that are running unreplicated pods. This mode will make the Evictor start considering application with just a single replica.
        """
        return pulumi.get(self, "aggressive_mode")

    @aggressive_mode.setter
    def aggressive_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "aggressive_mode", value)

    @_builtins.property
    @pulumi.getter(name="cycleInterval")
    def cycle_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        configure the interval duration between Evictor operations. This property can be used to lower or raise the frequency of the Evictor's find-and-drain operations.
        """
        return pulumi.get(self, "cycle_interval")

    @cycle_interval.setter
    def cycle_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cycle_interval", value)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable dry-run. This property allows you to prevent the Evictor from carrying any operations out and preview the actions it would take.
        """
        return pulumi.get(self, "dry_run")

    @dry_run.setter
    def dry_run(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dry_run", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable the Evictor policy. This will either install or uninstall the Evictor component in your cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="ignorePodDisruptionBudgets")
    def ignore_pod_disruption_budgets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        if enabled then Evictor will attempt to evict pods that have pod disruption budgets configured.
        """
        return pulumi.get(self, "ignore_pod_disruption_budgets")

    @ignore_pod_disruption_budgets.setter
    def ignore_pod_disruption_budgets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_pod_disruption_budgets", value)

    @_builtins.property
    @pulumi.getter(name="nodeGracePeriodMinutes")
    def node_grace_period_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        configure the node grace period which controls the duration which must pass after a node has been created before Evictor starts considering that node.
        """
        return pulumi.get(self, "node_grace_period_minutes")

    @node_grace_period_minutes.setter
    def node_grace_period_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_grace_period_minutes", value)

    @_builtins.property
    @pulumi.getter(name="podEvictionFailureBackOffInterval")
    def pod_eviction_failure_back_off_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        configure the pod eviction failure back off interval. If pod eviction fails then Evictor will attempt to evict it again after the amount of time specified here.
        """
        return pulumi.get(self, "pod_eviction_failure_back_off_interval")

    @pod_eviction_failure_back_off_interval.setter
    def pod_eviction_failure_back_off_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_eviction_failure_back_off_interval", value)

    @_builtins.property
    @pulumi.getter(name="scopedMode")
    def scoped_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable scoped mode. By default, Evictor targets all nodes in the cluster. This mode will constrain it to just the nodes which were created by CAST AI.
        """
        return pulumi.get(self, "scoped_mode")

    @scoped_mode.setter
    def scoped_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "scoped_mode", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsSpotInstancesArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable spot instances policy.
        """
        max_reclaim_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        max allowed reclaim rate when choosing spot instance type. E.g. if the value is 10%, instance types having 10% or higher reclaim rate will not be considered. Set to zero to use all instance types regardless of reclaim rate.
        """
        spot_backups: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgsDict']]
        """
        policy defining whether autoscaler can use spot backups instead of spot instances when spot instances are not available.
        """
        spot_diversity_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        """
        spot_diversity_price_increase_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        """
        spot_interruption_predictions: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgsDict']]
        """
        configure the handling of SPOT interruption predictions.
        """
elif False:
    AutoscalerAutoscalerSettingsSpotInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsSpotInstancesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_reclaim_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 spot_backups: Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs']] = None,
                 spot_diversity_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_diversity_price_increase_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 spot_interruption_predictions: Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable/disable spot instances policy.
        :param pulumi.Input[_builtins.int] max_reclaim_rate: max allowed reclaim rate when choosing spot instance type. E.g. if the value is 10%, instance types having 10% or higher reclaim rate will not be considered. Set to zero to use all instance types regardless of reclaim rate.
        :param pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs'] spot_backups: policy defining whether autoscaler can use spot backups instead of spot instances when spot instances are not available.
        :param pulumi.Input[_builtins.bool] spot_diversity_enabled: enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        :param pulumi.Input[_builtins.int] spot_diversity_price_increase_limit: allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        :param pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs'] spot_interruption_predictions: configure the handling of SPOT interruption predictions.
        """
        if enabled is not None:
            warnings.warn("""`enabled` under `spot_instances` is deprecated. To enable spot instances, set `constraints.spot = true` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""enabled is deprecated: `enabled` under `spot_instances` is deprecated. To enable spot instances, set `constraints.spot = true` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_reclaim_rate is not None:
            warnings.warn("""`max_reclaim_rate` under `spot_instances` is deprecated. This field has no direct equivalent in the config.NodeTemplate resource, and setting it will have no effect.""", DeprecationWarning)
            pulumi.log.warn("""max_reclaim_rate is deprecated: `max_reclaim_rate` under `spot_instances` is deprecated. This field has no direct equivalent in the config.NodeTemplate resource, and setting it will have no effect.""")
        if max_reclaim_rate is not None:
            pulumi.set(__self__, "max_reclaim_rate", max_reclaim_rate)
        if spot_backups is not None:
            warnings.warn("""`spot_backups` under `spot_instances` is deprecated. Configure spot backup behavior using `constraints.use_spot_fallbacks` and `constraints.fallback_restore_rate_seconds` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""spot_backups is deprecated: `spot_backups` under `spot_instances` is deprecated. Configure spot backup behavior using `constraints.use_spot_fallbacks` and `constraints.fallback_restore_rate_seconds` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
        if spot_backups is not None:
            pulumi.set(__self__, "spot_backups", spot_backups)
        if spot_diversity_enabled is not None:
            warnings.warn("""`spot_diversity_enabled` is deprecated. Use the `enable_spot_diversity` field within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""spot_diversity_enabled is deprecated: `spot_diversity_enabled` is deprecated. Use the `enable_spot_diversity` field within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
        if spot_diversity_enabled is not None:
            pulumi.set(__self__, "spot_diversity_enabled", spot_diversity_enabled)
        if spot_diversity_price_increase_limit is not None:
            warnings.warn("""`spot_diversity_price_increase_limit` is deprecated. Use `spot_diversity_price_increase_limit_percent` within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""spot_diversity_price_increase_limit is deprecated: `spot_diversity_price_increase_limit` is deprecated. Use `spot_diversity_price_increase_limit_percent` within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
        if spot_diversity_price_increase_limit is not None:
            pulumi.set(__self__, "spot_diversity_price_increase_limit", spot_diversity_price_increase_limit)
        if spot_interruption_predictions is not None:
            warnings.warn("""`spot_interruption_predictions` is deprecated. Use the `spot_interruption_predictions_enabled` and `spot_interruption_predictions_type` fields in the default config.NodeTemplate resource. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""spot_interruption_predictions is deprecated: `spot_interruption_predictions` is deprecated. Use the `spot_interruption_predictions_enabled` and `spot_interruption_predictions_type` fields in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
        if spot_interruption_predictions is not None:
            pulumi.set(__self__, "spot_interruption_predictions", spot_interruption_predictions)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`enabled` under `spot_instances` is deprecated. To enable spot instances, set `constraints.spot = true` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable spot instances policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxReclaimRate")
    @_utilities.deprecated("""`max_reclaim_rate` under `spot_instances` is deprecated. This field has no direct equivalent in the config.NodeTemplate resource, and setting it will have no effect.""")
    def max_reclaim_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        max allowed reclaim rate when choosing spot instance type. E.g. if the value is 10%, instance types having 10% or higher reclaim rate will not be considered. Set to zero to use all instance types regardless of reclaim rate.
        """
        return pulumi.get(self, "max_reclaim_rate")

    @max_reclaim_rate.setter
    def max_reclaim_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_reclaim_rate", value)

    @_builtins.property
    @pulumi.getter(name="spotBackups")
    @_utilities.deprecated("""`spot_backups` under `spot_instances` is deprecated. Configure spot backup behavior using `constraints.use_spot_fallbacks` and `constraints.fallback_restore_rate_seconds` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_backups(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs']]:
        """
        policy defining whether autoscaler can use spot backups instead of spot instances when spot instances are not available.
        """
        return pulumi.get(self, "spot_backups")

    @spot_backups.setter
    def spot_backups(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs']]):
        pulumi.set(self, "spot_backups", value)

    @_builtins.property
    @pulumi.getter(name="spotDiversityEnabled")
    @_utilities.deprecated("""`spot_diversity_enabled` is deprecated. Use the `enable_spot_diversity` field within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_diversity_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable spot diversity policy. When enabled, autoscaler will try to balance between diverse and cost optimal instance types.
        """
        return pulumi.get(self, "spot_diversity_enabled")

    @spot_diversity_enabled.setter
    def spot_diversity_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "spot_diversity_enabled", value)

    @_builtins.property
    @pulumi.getter(name="spotDiversityPriceIncreaseLimit")
    @_utilities.deprecated("""`spot_diversity_price_increase_limit` is deprecated. Use `spot_diversity_price_increase_limit_percent` within `castai_node_template.constraints` in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_diversity_price_increase_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        allowed node configuration price increase when diversifying instance types. E.g. if the value is 10%, then the overall price of diversified instance types can be 10% higher than the price of the optimal configuration.
        """
        return pulumi.get(self, "spot_diversity_price_increase_limit")

    @spot_diversity_price_increase_limit.setter
    def spot_diversity_price_increase_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_diversity_price_increase_limit", value)

    @_builtins.property
    @pulumi.getter(name="spotInterruptionPredictions")
    @_utilities.deprecated("""`spot_interruption_predictions` is deprecated. Use the `spot_interruption_predictions_enabled` and `spot_interruption_predictions_type` fields in the default config.NodeTemplate resource. The default node template has `is_default = true`.""")
    def spot_interruption_predictions(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs']]:
        """
        configure the handling of SPOT interruption predictions.
        """
        return pulumi.get(self, "spot_interruption_predictions")

    @spot_interruption_predictions.setter
    def spot_interruption_predictions(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs']]):
        pulumi.set(self, "spot_interruption_predictions", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable spot backups policy.
        """
        spot_backup_restore_rate_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines interval on how often spot backups restore to real spot should occur.
        """
elif False:
    AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsSpotInstancesSpotBackupsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_backup_restore_rate_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable/disable spot backups policy.
        :param pulumi.Input[_builtins.int] spot_backup_restore_rate_seconds: defines interval on how often spot backups restore to real spot should occur.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if spot_backup_restore_rate_seconds is not None:
            pulumi.set(__self__, "spot_backup_restore_rate_seconds", spot_backup_restore_rate_seconds)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable spot backups policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="spotBackupRestoreRateSeconds")
    def spot_backup_restore_rate_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines interval on how often spot backups restore to real spot should occur.
        """
        return pulumi.get(self, "spot_backup_restore_rate_seconds")

    @spot_backup_restore_rate_seconds.setter
    def spot_backup_restore_rate_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_backup_restore_rate_seconds", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable spot interruption predictions.
        """
        spot_interruption_predictions_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        define the type of the spot interruption prediction to handle. Allowed values are AWSRebalanceRecommendations, CASTAIInterruptionPredictions.
        """
elif False:
    AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsSpotInstancesSpotInterruptionPredictionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_interruption_predictions_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable/disable spot interruption predictions.
        :param pulumi.Input[_builtins.str] spot_interruption_predictions_type: define the type of the spot interruption prediction to handle. Allowed values are AWSRebalanceRecommendations, CASTAIInterruptionPredictions.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if spot_interruption_predictions_type is not None:
            pulumi.set(__self__, "spot_interruption_predictions_type", spot_interruption_predictions_type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable spot interruption predictions.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="spotInterruptionPredictionsType")
    def spot_interruption_predictions_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        define the type of the spot interruption prediction to handle. Allowed values are AWSRebalanceRecommendations, CASTAIInterruptionPredictions.
        """
        return pulumi.get(self, "spot_interruption_predictions_type")

    @spot_interruption_predictions_type.setter
    def spot_interruption_predictions_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_interruption_predictions_type", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsUnschedulablePodsArgsDict(TypedDict):
        custom_instances_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable custom instances policy.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable unschedulable pods detection policy.
        """
        headroom: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgsDict']]
        """
        additional headroom based on cluster's total available capacity for on-demand nodes.
        """
        headroom_spot: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgsDict']]
        """
        additional headroom based on cluster's total available capacity for spot nodes.
        """
        node_constraints: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgsDict']]
        """
        defines the node constraints that will be applied when autoscaling with Unschedulable Pods policy.
        """
        pod_pinner: NotRequired[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgsDict']]
        """
        defines the Cast AI Pod Pinner components settings.
        """
elif False:
    AutoscalerAutoscalerSettingsUnschedulablePodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsUnschedulablePodsArgs:
    def __init__(__self__, *,
                 custom_instances_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 headroom: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs']] = None,
                 headroom_spot: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs']] = None,
                 node_constraints: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs']] = None,
                 pod_pinner: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] custom_instances_enabled: enable/disable custom instances policy.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable unschedulable pods detection policy.
        :param pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs'] headroom: additional headroom based on cluster's total available capacity for on-demand nodes.
        :param pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs'] headroom_spot: additional headroom based on cluster's total available capacity for spot nodes.
        :param pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs'] node_constraints: defines the node constraints that will be applied when autoscaling with Unschedulable Pods policy.
        :param pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs'] pod_pinner: defines the Cast AI Pod Pinner components settings.
        """
        if custom_instances_enabled is not None:
            warnings.warn("""`custom_instances_enabled` under `unschedulable_pods.node_constraints` is deprecated. Use the `custom_instances_enabled` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""custom_instances_enabled is deprecated: `custom_instances_enabled` under `unschedulable_pods.node_constraints` is deprecated. Use the `custom_instances_enabled` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""")
        if custom_instances_enabled is not None:
            pulumi.set(__self__, "custom_instances_enabled", custom_instances_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headroom is not None:
            warnings.warn("""`headroom` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""", DeprecationWarning)
            pulumi.log.warn("""headroom is deprecated: `headroom` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""")
        if headroom is not None:
            pulumi.set(__self__, "headroom", headroom)
        if headroom_spot is not None:
            warnings.warn("""`headroom_spot` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""", DeprecationWarning)
            pulumi.log.warn("""headroom_spot is deprecated: `headroom_spot` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""")
        if headroom_spot is not None:
            pulumi.set(__self__, "headroom_spot", headroom_spot)
        if node_constraints is not None:
            warnings.warn("""`node_constraints` under `unschedulable_pods` is deprecated. Use the `constraints` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""", DeprecationWarning)
            pulumi.log.warn("""node_constraints is deprecated: `node_constraints` under `unschedulable_pods` is deprecated. Use the `constraints` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""")
        if node_constraints is not None:
            pulumi.set(__self__, "node_constraints", node_constraints)
        if pod_pinner is not None:
            pulumi.set(__self__, "pod_pinner", pod_pinner)

    @_builtins.property
    @pulumi.getter(name="customInstancesEnabled")
    @_utilities.deprecated("""`custom_instances_enabled` under `unschedulable_pods.node_constraints` is deprecated. Use the `custom_instances_enabled` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""")
    def custom_instances_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable custom instances policy.
        """
        return pulumi.get(self, "custom_instances_enabled")

    @custom_instances_enabled.setter
    def custom_instances_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "custom_instances_enabled", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable unschedulable pods detection policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`headroom` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""")
    def headroom(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs']]:
        """
        additional headroom based on cluster's total available capacity for on-demand nodes.
        """
        return pulumi.get(self, "headroom")

    @headroom.setter
    def headroom(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs']]):
        pulumi.set(self, "headroom", value)

    @_builtins.property
    @pulumi.getter(name="headroomSpot")
    @_utilities.deprecated("""`headroom_spot` is deprecated. Please refer to the FAQ for guidance on cluster headroom: https://docs.cast.ai/docs/autoscaler-1#can-you-please-share-some-guidance-on-cluster-headroom-i-would-like-to-add-some-buffer-room-so-that-pods-have-a-place-to-run-when-nodes-go-down""")
    def headroom_spot(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs']]:
        """
        additional headroom based on cluster's total available capacity for spot nodes.
        """
        return pulumi.get(self, "headroom_spot")

    @headroom_spot.setter
    def headroom_spot(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs']]):
        pulumi.set(self, "headroom_spot", value)

    @_builtins.property
    @pulumi.getter(name="nodeConstraints")
    @_utilities.deprecated("""`node_constraints` under `unschedulable_pods` is deprecated. Use the `constraints` field in the default config.NodeTemplate resource instead. The default node template has `is_default = true`.""")
    def node_constraints(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs']]:
        """
        defines the node constraints that will be applied when autoscaling with Unschedulable Pods policy.
        """
        return pulumi.get(self, "node_constraints")

    @node_constraints.setter
    def node_constraints(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs']]):
        pulumi.set(self, "node_constraints", value)

    @_builtins.property
    @pulumi.getter(name="podPinner")
    def pod_pinner(self) -> Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs']]:
        """
        defines the Cast AI Pod Pinner components settings.
        """
        return pulumi.get(self, "pod_pinner")

    @pod_pinner.setter
    def pod_pinner(self, value: Optional[pulumi.Input['AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs']]):
        pulumi.set(self, "pod_pinner", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgsDict(TypedDict):
        cpu_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines percentage of additional CPU capacity to be added.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable headroom policy.
        """
        memory_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines percentage of additional memory capacity to be added.
        """
elif False:
    AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomArgs:
    def __init__(__self__, *,
                 cpu_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 memory_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_percentage: defines percentage of additional CPU capacity to be added.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable headroom policy.
        :param pulumi.Input[_builtins.int] memory_percentage: defines percentage of additional memory capacity to be added.
        """
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines percentage of additional CPU capacity to be added.
        """
        return pulumi.get(self, "cpu_percentage")

    @cpu_percentage.setter
    def cpu_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_percentage", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable headroom policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines percentage of additional memory capacity to be added.
        """
        return pulumi.get(self, "memory_percentage")

    @memory_percentage.setter
    def memory_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory_percentage", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgsDict(TypedDict):
        cpu_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines percentage of additional CPU capacity to be added.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable headroom_spot policy.
        """
        memory_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines percentage of additional memory capacity to be added.
        """
elif False:
    AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsUnschedulablePodsHeadroomSpotArgs:
    def __init__(__self__, *,
                 cpu_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 memory_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_percentage: defines percentage of additional CPU capacity to be added.
        :param pulumi.Input[_builtins.bool] enabled: enable/disable headroom_spot policy.
        :param pulumi.Input[_builtins.int] memory_percentage: defines percentage of additional memory capacity to be added.
        """
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines percentage of additional CPU capacity to be added.
        """
        return pulumi.get(self, "cpu_percentage")

    @cpu_percentage.setter
    def cpu_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_percentage", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable headroom_spot policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines percentage of additional memory capacity to be added.
        """
        return pulumi.get(self, "memory_percentage")

    @memory_percentage.setter
    def memory_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory_percentage", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable node constraints policy.
        """
        max_cpu_cores: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines max CPU cores for the node to pick.
        """
        max_ram_mib: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines max RAM in MiB for the node to pick.
        """
        min_cpu_cores: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines min CPU cores for the node to pick.
        """
        min_ram_mib: NotRequired[pulumi.Input[_builtins.int]]
        """
        defines min RAM in MiB for the node to pick.
        """
elif False:
    AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsUnschedulablePodsNodeConstraintsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_cpu_cores: Optional[pulumi.Input[_builtins.int]] = None,
                 max_ram_mib: Optional[pulumi.Input[_builtins.int]] = None,
                 min_cpu_cores: Optional[pulumi.Input[_builtins.int]] = None,
                 min_ram_mib: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable/disable node constraints policy.
        :param pulumi.Input[_builtins.int] max_cpu_cores: defines max CPU cores for the node to pick.
        :param pulumi.Input[_builtins.int] max_ram_mib: defines max RAM in MiB for the node to pick.
        :param pulumi.Input[_builtins.int] min_cpu_cores: defines min CPU cores for the node to pick.
        :param pulumi.Input[_builtins.int] min_ram_mib: defines min RAM in MiB for the node to pick.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_cpu_cores is not None:
            pulumi.set(__self__, "max_cpu_cores", max_cpu_cores)
        if max_ram_mib is not None:
            pulumi.set(__self__, "max_ram_mib", max_ram_mib)
        if min_cpu_cores is not None:
            pulumi.set(__self__, "min_cpu_cores", min_cpu_cores)
        if min_ram_mib is not None:
            pulumi.set(__self__, "min_ram_mib", min_ram_mib)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable node constraints policy.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxCpuCores")
    def max_cpu_cores(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines max CPU cores for the node to pick.
        """
        return pulumi.get(self, "max_cpu_cores")

    @max_cpu_cores.setter
    def max_cpu_cores(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_cpu_cores", value)

    @_builtins.property
    @pulumi.getter(name="maxRamMib")
    def max_ram_mib(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines max RAM in MiB for the node to pick.
        """
        return pulumi.get(self, "max_ram_mib")

    @max_ram_mib.setter
    def max_ram_mib(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ram_mib", value)

    @_builtins.property
    @pulumi.getter(name="minCpuCores")
    def min_cpu_cores(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines min CPU cores for the node to pick.
        """
        return pulumi.get(self, "min_cpu_cores")

    @min_cpu_cores.setter
    def min_cpu_cores(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_cpu_cores", value)

    @_builtins.property
    @pulumi.getter(name="minRamMib")
    def min_ram_mib(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        defines min RAM in MiB for the node to pick.
        """
        return pulumi.get(self, "min_ram_mib")

    @min_ram_mib.setter
    def min_ram_mib(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_ram_mib", value)


if not MYPY:
    class AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        enable/disable the Pod Pinner component's automatic management in your cluster. Default: enabled.
        """
elif False:
    AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalerAutoscalerSettingsUnschedulablePodsPodPinnerArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: enable/disable the Pod Pinner component's automatic management in your cluster. Default: enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        enable/disable the Pod Pinner component's automatic management in your cluster. Default: enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class EvictorAdvancedConfigEvictorAdvancedConfigArgsDict(TypedDict):
        aggressive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Apply Aggressive mode to Evictor
        """
        disposable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mark node as disposable
        """
        node_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgsDict']]]]
        """
        node selector
        """
        pod_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgsDict']]]]
        """
        pod selector
        """
        removal_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mark pods as removal disabled
        """
elif False:
    EvictorAdvancedConfigEvictorAdvancedConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvictorAdvancedConfigEvictorAdvancedConfigArgs:
    def __init__(__self__, *,
                 aggressive: Optional[pulumi.Input[_builtins.bool]] = None,
                 disposable: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs']]]] = None,
                 pod_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs']]]] = None,
                 removal_disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] aggressive: Apply Aggressive mode to Evictor
        :param pulumi.Input[_builtins.bool] disposable: Mark node as disposable
        :param pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs']]] node_selectors: node selector
        :param pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs']]] pod_selectors: pod selector
        :param pulumi.Input[_builtins.bool] removal_disabled: Mark pods as removal disabled
        """
        if aggressive is not None:
            pulumi.set(__self__, "aggressive", aggressive)
        if disposable is not None:
            pulumi.set(__self__, "disposable", disposable)
        if node_selectors is not None:
            pulumi.set(__self__, "node_selectors", node_selectors)
        if pod_selectors is not None:
            pulumi.set(__self__, "pod_selectors", pod_selectors)
        if removal_disabled is not None:
            pulumi.set(__self__, "removal_disabled", removal_disabled)

    @_builtins.property
    @pulumi.getter
    def aggressive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Apply Aggressive mode to Evictor
        """
        return pulumi.get(self, "aggressive")

    @aggressive.setter
    def aggressive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "aggressive", value)

    @_builtins.property
    @pulumi.getter
    def disposable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mark node as disposable
        """
        return pulumi.get(self, "disposable")

    @disposable.setter
    def disposable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disposable", value)

    @_builtins.property
    @pulumi.getter(name="nodeSelectors")
    def node_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs']]]]:
        """
        node selector
        """
        return pulumi.get(self, "node_selectors")

    @node_selectors.setter
    def node_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs']]]]):
        pulumi.set(self, "node_selectors", value)

    @_builtins.property
    @pulumi.getter(name="podSelectors")
    def pod_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs']]]]:
        """
        pod selector
        """
        return pulumi.get(self, "pod_selectors")

    @pod_selectors.setter
    def pod_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs']]]]):
        pulumi.set(self, "pod_selectors", value)

    @_builtins.property
    @pulumi.getter(name="removalDisabled")
    def removal_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mark pods as removal disabled
        """
        return pulumi.get(self, "removal_disabled")

    @removal_disabled.setter
    def removal_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "removal_disabled", value)


if not MYPY:
    class EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvictorAdvancedConfigEvictorAdvancedConfigNodeSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[_builtins.str]]
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvictorAdvancedConfigEvictorAdvancedConfigPodSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


